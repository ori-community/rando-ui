/* eslint-disable */
import $protobuf from 'protobufjs'

// THIS IS AN AUTOGENERATED FILE
// DO NOT EDIT!

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const RandoProto = $root.RandoProto = (() => {

    /**
     * Namespace RandoProto.
     * @exports RandoProto
     * @namespace
     */
    const RandoProto = {};

    RandoProto.Packet = (function() {

        /**
         * Properties of a Packet.
         * @memberof RandoProto
         * @interface IPacket
         * @property {number|null} [id] Packet id
         * @property {Uint8Array|null} [packet] Packet packet
         */

        /**
         * Constructs a new Packet.
         * @memberof RandoProto
         * @classdesc Represents a Packet.
         * @implements IPacket
         * @constructor
         * @param {RandoProto.IPacket=} [properties] Properties to set
         */
        function Packet(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Packet id.
         * @member {number} id
         * @memberof RandoProto.Packet
         * @instance
         */
        Packet.prototype.id = 0;

        /**
         * Packet packet.
         * @member {Uint8Array} packet
         * @memberof RandoProto.Packet
         * @instance
         */
        Packet.prototype.packet = $util.newBuffer([]);

        /**
         * Creates a new Packet instance using the specified properties.
         * @function create
         * @memberof RandoProto.Packet
         * @static
         * @param {RandoProto.IPacket=} [properties] Properties to set
         * @returns {RandoProto.Packet} Packet instance
         */
        Packet.create = function create(properties) {
            return new Packet(properties);
        };

        /**
         * Encodes the specified Packet message. Does not implicitly {@link RandoProto.Packet.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.Packet
         * @static
         * @param {RandoProto.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.packet != null && Object.hasOwnProperty.call(message, "packet"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.packet);
            return writer;
        };

        /**
         * Encodes the specified Packet message, length delimited. Does not implicitly {@link RandoProto.Packet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.Packet
         * @static
         * @param {RandoProto.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Packet message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.Packet();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.packet = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Packet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Packet message.
         * @function verify
         * @memberof RandoProto.Packet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Packet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.packet != null && message.hasOwnProperty("packet"))
                if (!(message.packet && typeof message.packet.length === "number" || $util.isString(message.packet)))
                    return "packet: buffer expected";
            return null;
        };

        /**
         * Creates a Packet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.Packet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.Packet} Packet
         */
        Packet.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.Packet)
                return object;
            let message = new $root.RandoProto.Packet();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.packet != null)
                if (typeof object.packet === "string")
                    $util.base64.decode(object.packet, message.packet = $util.newBuffer($util.base64.length(object.packet)), 0);
                else if (object.packet.length)
                    message.packet = object.packet;
            return message;
        };

        /**
         * Creates a plain object from a Packet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.Packet
         * @static
         * @param {RandoProto.Packet} message Packet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Packet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                if (options.bytes === String)
                    object.packet = "";
                else {
                    object.packet = [];
                    if (options.bytes !== Array)
                        object.packet = $util.newBuffer(object.packet);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.packet != null && message.hasOwnProperty("packet"))
                object.packet = options.bytes === String ? $util.base64.encode(message.packet, 0, message.packet.length) : options.bytes === Array ? Array.prototype.slice.call(message.packet) : message.packet;
            return object;
        };

        /**
         * Converts this Packet to JSON.
         * @function toJSON
         * @memberof RandoProto.Packet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Packet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Packet
         * @function getTypeUrl
         * @memberof RandoProto.Packet
         * @static
         * @returns {string} The default type url
         */
        Packet.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.Packet";
        };

        return Packet;
    })();

    RandoProto.BingoGoal = (function() {

        /**
         * Properties of a BingoGoal.
         * @memberof RandoProto
         * @interface IBingoGoal
         * @property {string|null} [text] BingoGoal text
         * @property {boolean|null} [completed] BingoGoal completed
         */

        /**
         * Constructs a new BingoGoal.
         * @memberof RandoProto
         * @classdesc Represents a BingoGoal.
         * @implements IBingoGoal
         * @constructor
         * @param {RandoProto.IBingoGoal=} [properties] Properties to set
         */
        function BingoGoal(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BingoGoal text.
         * @member {string} text
         * @memberof RandoProto.BingoGoal
         * @instance
         */
        BingoGoal.prototype.text = "";

        /**
         * BingoGoal completed.
         * @member {boolean} completed
         * @memberof RandoProto.BingoGoal
         * @instance
         */
        BingoGoal.prototype.completed = false;

        /**
         * Creates a new BingoGoal instance using the specified properties.
         * @function create
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {RandoProto.IBingoGoal=} [properties] Properties to set
         * @returns {RandoProto.BingoGoal} BingoGoal instance
         */
        BingoGoal.create = function create(properties) {
            return new BingoGoal(properties);
        };

        /**
         * Encodes the specified BingoGoal message. Does not implicitly {@link RandoProto.BingoGoal.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {RandoProto.IBingoGoal} message BingoGoal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoGoal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.completed != null && Object.hasOwnProperty.call(message, "completed"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.completed);
            return writer;
        };

        /**
         * Encodes the specified BingoGoal message, length delimited. Does not implicitly {@link RandoProto.BingoGoal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {RandoProto.IBingoGoal} message BingoGoal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoGoal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BingoGoal message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.BingoGoal} BingoGoal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoGoal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.BingoGoal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.completed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BingoGoal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.BingoGoal} BingoGoal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoGoal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BingoGoal message.
         * @function verify
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BingoGoal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.completed != null && message.hasOwnProperty("completed"))
                if (typeof message.completed !== "boolean")
                    return "completed: boolean expected";
            return null;
        };

        /**
         * Creates a BingoGoal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.BingoGoal} BingoGoal
         */
        BingoGoal.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.BingoGoal)
                return object;
            let message = new $root.RandoProto.BingoGoal();
            if (object.text != null)
                message.text = String(object.text);
            if (object.completed != null)
                message.completed = Boolean(object.completed);
            return message;
        };

        /**
         * Creates a plain object from a BingoGoal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {RandoProto.BingoGoal} message BingoGoal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BingoGoal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.text = "";
                object.completed = false;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.completed != null && message.hasOwnProperty("completed"))
                object.completed = message.completed;
            return object;
        };

        /**
         * Converts this BingoGoal to JSON.
         * @function toJSON
         * @memberof RandoProto.BingoGoal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BingoGoal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BingoGoal
         * @function getTypeUrl
         * @memberof RandoProto.BingoGoal
         * @static
         * @returns {string} The default type url
         */
        BingoGoal.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.BingoGoal";
        };

        return BingoGoal;
    })();

    RandoProto.UserInfo = (function() {

        /**
         * Properties of a UserInfo.
         * @memberof RandoProto
         * @interface IUserInfo
         * @property {string|null} [id] UserInfo id
         * @property {string|null} [name] UserInfo name
         * @property {string|null} [avatarId] UserInfo avatarId
         */

        /**
         * Constructs a new UserInfo.
         * @memberof RandoProto
         * @classdesc Represents a UserInfo.
         * @implements IUserInfo
         * @constructor
         * @param {RandoProto.IUserInfo=} [properties] Properties to set
         */
        function UserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfo id.
         * @member {string} id
         * @memberof RandoProto.UserInfo
         * @instance
         */
        UserInfo.prototype.id = "";

        /**
         * UserInfo name.
         * @member {string} name
         * @memberof RandoProto.UserInfo
         * @instance
         */
        UserInfo.prototype.name = "";

        /**
         * UserInfo avatarId.
         * @member {string|null|undefined} avatarId
         * @memberof RandoProto.UserInfo
         * @instance
         */
        UserInfo.prototype.avatarId = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * UserInfo _avatarId.
         * @member {"avatarId"|undefined} _avatarId
         * @memberof RandoProto.UserInfo
         * @instance
         */
        Object.defineProperty(UserInfo.prototype, "_avatarId", {
            get: $util.oneOfGetter($oneOfFields = ["avatarId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new UserInfo instance using the specified properties.
         * @function create
         * @memberof RandoProto.UserInfo
         * @static
         * @param {RandoProto.IUserInfo=} [properties] Properties to set
         * @returns {RandoProto.UserInfo} UserInfo instance
         */
        UserInfo.create = function create(properties) {
            return new UserInfo(properties);
        };

        /**
         * Encodes the specified UserInfo message. Does not implicitly {@link RandoProto.UserInfo.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.UserInfo
         * @static
         * @param {RandoProto.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarId);
            return writer;
        };

        /**
         * Encodes the specified UserInfo message, length delimited. Does not implicitly {@link RandoProto.UserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.UserInfo
         * @static
         * @param {RandoProto.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.UserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatarId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserInfo message.
         * @function verify
         * @memberof RandoProto.UserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId")) {
                properties._avatarId = 1;
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            }
            return null;
        };

        /**
         * Creates a UserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.UserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.UserInfo} UserInfo
         */
        UserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.UserInfo)
                return object;
            let message = new $root.RandoProto.UserInfo();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            return message;
        };

        /**
         * Creates a plain object from a UserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.UserInfo
         * @static
         * @param {RandoProto.UserInfo} message UserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId")) {
                object.avatarId = message.avatarId;
                if (options.oneofs)
                    object._avatarId = "avatarId";
            }
            return object;
        };

        /**
         * Converts this UserInfo to JSON.
         * @function toJSON
         * @memberof RandoProto.UserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserInfo
         * @function getTypeUrl
         * @memberof RandoProto.UserInfo
         * @static
         * @returns {string} The default type url
         */
        UserInfo.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.UserInfo";
        };

        return UserInfo;
    })();

    RandoProto.TeamInfo = (function() {

        /**
         * Properties of a TeamInfo.
         * @memberof RandoProto
         * @interface ITeamInfo
         * @property {number|Long|null} [id] TeamInfo id
         * @property {string|null} [name] TeamInfo name
         * @property {Array.<RandoProto.IUserInfo>|null} [members] TeamInfo members
         */

        /**
         * Constructs a new TeamInfo.
         * @memberof RandoProto
         * @classdesc Represents a TeamInfo.
         * @implements ITeamInfo
         * @constructor
         * @param {RandoProto.ITeamInfo=} [properties] Properties to set
         */
        function TeamInfo(properties) {
            this.members = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TeamInfo id.
         * @member {number|Long} id
         * @memberof RandoProto.TeamInfo
         * @instance
         */
        TeamInfo.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TeamInfo name.
         * @member {string} name
         * @memberof RandoProto.TeamInfo
         * @instance
         */
        TeamInfo.prototype.name = "";

        /**
         * TeamInfo members.
         * @member {Array.<RandoProto.IUserInfo>} members
         * @memberof RandoProto.TeamInfo
         * @instance
         */
        TeamInfo.prototype.members = $util.emptyArray;

        /**
         * Creates a new TeamInfo instance using the specified properties.
         * @function create
         * @memberof RandoProto.TeamInfo
         * @static
         * @param {RandoProto.ITeamInfo=} [properties] Properties to set
         * @returns {RandoProto.TeamInfo} TeamInfo instance
         */
        TeamInfo.create = function create(properties) {
            return new TeamInfo(properties);
        };

        /**
         * Encodes the specified TeamInfo message. Does not implicitly {@link RandoProto.TeamInfo.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.TeamInfo
         * @static
         * @param {RandoProto.ITeamInfo} message TeamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TeamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.members != null && message.members.length)
                for (let i = 0; i < message.members.length; ++i)
                    $root.RandoProto.UserInfo.encode(message.members[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TeamInfo message, length delimited. Does not implicitly {@link RandoProto.TeamInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.TeamInfo
         * @static
         * @param {RandoProto.ITeamInfo} message TeamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TeamInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TeamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.TeamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.TeamInfo} TeamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.TeamInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.RandoProto.UserInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TeamInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.TeamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.TeamInfo} TeamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TeamInfo message.
         * @function verify
         * @memberof RandoProto.TeamInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TeamInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (let i = 0; i < message.members.length; ++i) {
                    let error = $root.RandoProto.UserInfo.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TeamInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.TeamInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.TeamInfo} TeamInfo
         */
        TeamInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.TeamInfo)
                return object;
            let message = new $root.RandoProto.TeamInfo();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".RandoProto.TeamInfo.members: array expected");
                message.members = [];
                for (let i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".RandoProto.TeamInfo.members: object expected");
                    message.members[i] = $root.RandoProto.UserInfo.fromObject(object.members[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TeamInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.TeamInfo
         * @static
         * @param {RandoProto.TeamInfo} message TeamInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TeamInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.members && message.members.length) {
                object.members = [];
                for (let j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.RandoProto.UserInfo.toObject(message.members[j], options);
            }
            return object;
        };

        /**
         * Converts this TeamInfo to JSON.
         * @function toJSON
         * @memberof RandoProto.TeamInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TeamInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TeamInfo
         * @function getTypeUrl
         * @memberof RandoProto.TeamInfo
         * @static
         * @returns {string} The default type url
         */
        TeamInfo.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.TeamInfo";
        };

        return TeamInfo;
    })();

    RandoProto.GameInfo = (function() {

        /**
         * Properties of a GameInfo.
         * @memberof RandoProto
         * @interface IGameInfo
         * @property {number|Long|null} [id] GameInfo id
         * @property {Array.<RandoProto.ITeamInfo>|null} [teams] GameInfo teams
         * @property {boolean|null} [hasBingoBoard] GameInfo hasBingoBoard
         */

        /**
         * Constructs a new GameInfo.
         * @memberof RandoProto
         * @classdesc Represents a GameInfo.
         * @implements IGameInfo
         * @constructor
         * @param {RandoProto.IGameInfo=} [properties] Properties to set
         */
        function GameInfo(properties) {
            this.teams = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameInfo id.
         * @member {number|Long} id
         * @memberof RandoProto.GameInfo
         * @instance
         */
        GameInfo.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GameInfo teams.
         * @member {Array.<RandoProto.ITeamInfo>} teams
         * @memberof RandoProto.GameInfo
         * @instance
         */
        GameInfo.prototype.teams = $util.emptyArray;

        /**
         * GameInfo hasBingoBoard.
         * @member {boolean} hasBingoBoard
         * @memberof RandoProto.GameInfo
         * @instance
         */
        GameInfo.prototype.hasBingoBoard = false;

        /**
         * Creates a new GameInfo instance using the specified properties.
         * @function create
         * @memberof RandoProto.GameInfo
         * @static
         * @param {RandoProto.IGameInfo=} [properties] Properties to set
         * @returns {RandoProto.GameInfo} GameInfo instance
         */
        GameInfo.create = function create(properties) {
            return new GameInfo(properties);
        };

        /**
         * Encodes the specified GameInfo message. Does not implicitly {@link RandoProto.GameInfo.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.GameInfo
         * @static
         * @param {RandoProto.IGameInfo} message GameInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.teams != null && message.teams.length)
                for (let i = 0; i < message.teams.length; ++i)
                    $root.RandoProto.TeamInfo.encode(message.teams[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hasBingoBoard != null && Object.hasOwnProperty.call(message, "hasBingoBoard"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasBingoBoard);
            return writer;
        };

        /**
         * Encodes the specified GameInfo message, length delimited. Does not implicitly {@link RandoProto.GameInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.GameInfo
         * @static
         * @param {RandoProto.IGameInfo} message GameInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.GameInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.GameInfo} GameInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.GameInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    if (!(message.teams && message.teams.length))
                        message.teams = [];
                    message.teams.push($root.RandoProto.TeamInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.hasBingoBoard = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.GameInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.GameInfo} GameInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameInfo message.
         * @function verify
         * @memberof RandoProto.GameInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.teams != null && message.hasOwnProperty("teams")) {
                if (!Array.isArray(message.teams))
                    return "teams: array expected";
                for (let i = 0; i < message.teams.length; ++i) {
                    let error = $root.RandoProto.TeamInfo.verify(message.teams[i]);
                    if (error)
                        return "teams." + error;
                }
            }
            if (message.hasBingoBoard != null && message.hasOwnProperty("hasBingoBoard"))
                if (typeof message.hasBingoBoard !== "boolean")
                    return "hasBingoBoard: boolean expected";
            return null;
        };

        /**
         * Creates a GameInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.GameInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.GameInfo} GameInfo
         */
        GameInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.GameInfo)
                return object;
            let message = new $root.RandoProto.GameInfo();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.teams) {
                if (!Array.isArray(object.teams))
                    throw TypeError(".RandoProto.GameInfo.teams: array expected");
                message.teams = [];
                for (let i = 0; i < object.teams.length; ++i) {
                    if (typeof object.teams[i] !== "object")
                        throw TypeError(".RandoProto.GameInfo.teams: object expected");
                    message.teams[i] = $root.RandoProto.TeamInfo.fromObject(object.teams[i]);
                }
            }
            if (object.hasBingoBoard != null)
                message.hasBingoBoard = Boolean(object.hasBingoBoard);
            return message;
        };

        /**
         * Creates a plain object from a GameInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.GameInfo
         * @static
         * @param {RandoProto.GameInfo} message GameInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.teams = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.hasBingoBoard = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.teams && message.teams.length) {
                object.teams = [];
                for (let j = 0; j < message.teams.length; ++j)
                    object.teams[j] = $root.RandoProto.TeamInfo.toObject(message.teams[j], options);
            }
            if (message.hasBingoBoard != null && message.hasOwnProperty("hasBingoBoard"))
                object.hasBingoBoard = message.hasBingoBoard;
            return object;
        };

        /**
         * Converts this GameInfo to JSON.
         * @function toJSON
         * @memberof RandoProto.GameInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GameInfo
         * @function getTypeUrl
         * @memberof RandoProto.GameInfo
         * @static
         * @returns {string} The default type url
         */
        GameInfo.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.GameInfo";
        };

        return GameInfo;
    })();

    RandoProto.BingoSquare = (function() {

        /**
         * Properties of a BingoSquare.
         * @memberof RandoProto
         * @interface IBingoSquare
         * @property {string|null} [text] BingoSquare text
         * @property {Array.<RandoProto.ITeamInfo>|null} [completedBy] BingoSquare completedBy
         * @property {Array.<RandoProto.IBingoGoal>|null} [goals] BingoSquare goals
         */

        /**
         * Constructs a new BingoSquare.
         * @memberof RandoProto
         * @classdesc Represents a BingoSquare.
         * @implements IBingoSquare
         * @constructor
         * @param {RandoProto.IBingoSquare=} [properties] Properties to set
         */
        function BingoSquare(properties) {
            this.completedBy = [];
            this.goals = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BingoSquare text.
         * @member {string} text
         * @memberof RandoProto.BingoSquare
         * @instance
         */
        BingoSquare.prototype.text = "";

        /**
         * BingoSquare completedBy.
         * @member {Array.<RandoProto.ITeamInfo>} completedBy
         * @memberof RandoProto.BingoSquare
         * @instance
         */
        BingoSquare.prototype.completedBy = $util.emptyArray;

        /**
         * BingoSquare goals.
         * @member {Array.<RandoProto.IBingoGoal>} goals
         * @memberof RandoProto.BingoSquare
         * @instance
         */
        BingoSquare.prototype.goals = $util.emptyArray;

        /**
         * Creates a new BingoSquare instance using the specified properties.
         * @function create
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {RandoProto.IBingoSquare=} [properties] Properties to set
         * @returns {RandoProto.BingoSquare} BingoSquare instance
         */
        BingoSquare.create = function create(properties) {
            return new BingoSquare(properties);
        };

        /**
         * Encodes the specified BingoSquare message. Does not implicitly {@link RandoProto.BingoSquare.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {RandoProto.IBingoSquare} message BingoSquare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoSquare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.completedBy != null && message.completedBy.length)
                for (let i = 0; i < message.completedBy.length; ++i)
                    $root.RandoProto.TeamInfo.encode(message.completedBy[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.goals != null && message.goals.length)
                for (let i = 0; i < message.goals.length; ++i)
                    $root.RandoProto.BingoGoal.encode(message.goals[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BingoSquare message, length delimited. Does not implicitly {@link RandoProto.BingoSquare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {RandoProto.IBingoSquare} message BingoSquare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoSquare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BingoSquare message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.BingoSquare} BingoSquare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoSquare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.BingoSquare();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    if (!(message.completedBy && message.completedBy.length))
                        message.completedBy = [];
                    message.completedBy.push($root.RandoProto.TeamInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.goals && message.goals.length))
                        message.goals = [];
                    message.goals.push($root.RandoProto.BingoGoal.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BingoSquare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.BingoSquare} BingoSquare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoSquare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BingoSquare message.
         * @function verify
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BingoSquare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.completedBy != null && message.hasOwnProperty("completedBy")) {
                if (!Array.isArray(message.completedBy))
                    return "completedBy: array expected";
                for (let i = 0; i < message.completedBy.length; ++i) {
                    let error = $root.RandoProto.TeamInfo.verify(message.completedBy[i]);
                    if (error)
                        return "completedBy." + error;
                }
            }
            if (message.goals != null && message.hasOwnProperty("goals")) {
                if (!Array.isArray(message.goals))
                    return "goals: array expected";
                for (let i = 0; i < message.goals.length; ++i) {
                    let error = $root.RandoProto.BingoGoal.verify(message.goals[i]);
                    if (error)
                        return "goals." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BingoSquare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.BingoSquare} BingoSquare
         */
        BingoSquare.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.BingoSquare)
                return object;
            let message = new $root.RandoProto.BingoSquare();
            if (object.text != null)
                message.text = String(object.text);
            if (object.completedBy) {
                if (!Array.isArray(object.completedBy))
                    throw TypeError(".RandoProto.BingoSquare.completedBy: array expected");
                message.completedBy = [];
                for (let i = 0; i < object.completedBy.length; ++i) {
                    if (typeof object.completedBy[i] !== "object")
                        throw TypeError(".RandoProto.BingoSquare.completedBy: object expected");
                    message.completedBy[i] = $root.RandoProto.TeamInfo.fromObject(object.completedBy[i]);
                }
            }
            if (object.goals) {
                if (!Array.isArray(object.goals))
                    throw TypeError(".RandoProto.BingoSquare.goals: array expected");
                message.goals = [];
                for (let i = 0; i < object.goals.length; ++i) {
                    if (typeof object.goals[i] !== "object")
                        throw TypeError(".RandoProto.BingoSquare.goals: object expected");
                    message.goals[i] = $root.RandoProto.BingoGoal.fromObject(object.goals[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BingoSquare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {RandoProto.BingoSquare} message BingoSquare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BingoSquare.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.completedBy = [];
                object.goals = [];
            }
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.completedBy && message.completedBy.length) {
                object.completedBy = [];
                for (let j = 0; j < message.completedBy.length; ++j)
                    object.completedBy[j] = $root.RandoProto.TeamInfo.toObject(message.completedBy[j], options);
            }
            if (message.goals && message.goals.length) {
                object.goals = [];
                for (let j = 0; j < message.goals.length; ++j)
                    object.goals[j] = $root.RandoProto.BingoGoal.toObject(message.goals[j], options);
            }
            return object;
        };

        /**
         * Converts this BingoSquare to JSON.
         * @function toJSON
         * @memberof RandoProto.BingoSquare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BingoSquare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BingoSquare
         * @function getTypeUrl
         * @memberof RandoProto.BingoSquare
         * @static
         * @returns {string} The default type url
         */
        BingoSquare.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.BingoSquare";
        };

        return BingoSquare;
    })();

    RandoProto.RequestUpdatesMessage = (function() {

        /**
         * Properties of a RequestUpdatesMessage.
         * @memberof RandoProto
         * @interface IRequestUpdatesMessage
         * @property {string|null} [playerId] RequestUpdatesMessage playerId
         */

        /**
         * Constructs a new RequestUpdatesMessage.
         * @memberof RandoProto
         * @classdesc Represents a RequestUpdatesMessage.
         * @implements IRequestUpdatesMessage
         * @constructor
         * @param {RandoProto.IRequestUpdatesMessage=} [properties] Properties to set
         */
        function RequestUpdatesMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestUpdatesMessage playerId.
         * @member {string} playerId
         * @memberof RandoProto.RequestUpdatesMessage
         * @instance
         */
        RequestUpdatesMessage.prototype.playerId = "";

        /**
         * Creates a new RequestUpdatesMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {RandoProto.IRequestUpdatesMessage=} [properties] Properties to set
         * @returns {RandoProto.RequestUpdatesMessage} RequestUpdatesMessage instance
         */
        RequestUpdatesMessage.create = function create(properties) {
            return new RequestUpdatesMessage(properties);
        };

        /**
         * Encodes the specified RequestUpdatesMessage message. Does not implicitly {@link RandoProto.RequestUpdatesMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {RandoProto.IRequestUpdatesMessage} message RequestUpdatesMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestUpdatesMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && Object.hasOwnProperty.call(message, "playerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerId);
            return writer;
        };

        /**
         * Encodes the specified RequestUpdatesMessage message, length delimited. Does not implicitly {@link RandoProto.RequestUpdatesMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {RandoProto.IRequestUpdatesMessage} message RequestUpdatesMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestUpdatesMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestUpdatesMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.RequestUpdatesMessage} RequestUpdatesMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestUpdatesMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.RequestUpdatesMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RequestUpdatesMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.RequestUpdatesMessage} RequestUpdatesMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestUpdatesMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestUpdatesMessage message.
         * @function verify
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestUpdatesMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isString(message.playerId))
                    return "playerId: string expected";
            return null;
        };

        /**
         * Creates a RequestUpdatesMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.RequestUpdatesMessage} RequestUpdatesMessage
         */
        RequestUpdatesMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.RequestUpdatesMessage)
                return object;
            let message = new $root.RandoProto.RequestUpdatesMessage();
            if (object.playerId != null)
                message.playerId = String(object.playerId);
            return message;
        };

        /**
         * Creates a plain object from a RequestUpdatesMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {RandoProto.RequestUpdatesMessage} message RequestUpdatesMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestUpdatesMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.playerId = "";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = message.playerId;
            return object;
        };

        /**
         * Converts this RequestUpdatesMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.RequestUpdatesMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestUpdatesMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RequestUpdatesMessage
         * @function getTypeUrl
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @returns {string} The default type url
         */
        RequestUpdatesMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.RequestUpdatesMessage";
        };

        return RequestUpdatesMessage;
    })();

    RandoProto.BingoTeamInfo = (function() {

        /**
         * Properties of a BingoTeamInfo.
         * @memberof RandoProto
         * @interface IBingoTeamInfo
         * @property {number|Long|null} [teamId] BingoTeamInfo teamId
         * @property {string|null} [score] BingoTeamInfo score
         * @property {number|null} [rank] BingoTeamInfo rank
         * @property {number|null} [squares] BingoTeamInfo squares
         * @property {number|null} [lines] BingoTeamInfo lines
         */

        /**
         * Constructs a new BingoTeamInfo.
         * @memberof RandoProto
         * @classdesc Represents a BingoTeamInfo.
         * @implements IBingoTeamInfo
         * @constructor
         * @param {RandoProto.IBingoTeamInfo=} [properties] Properties to set
         */
        function BingoTeamInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BingoTeamInfo teamId.
         * @member {number|Long} teamId
         * @memberof RandoProto.BingoTeamInfo
         * @instance
         */
        BingoTeamInfo.prototype.teamId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BingoTeamInfo score.
         * @member {string} score
         * @memberof RandoProto.BingoTeamInfo
         * @instance
         */
        BingoTeamInfo.prototype.score = "";

        /**
         * BingoTeamInfo rank.
         * @member {number} rank
         * @memberof RandoProto.BingoTeamInfo
         * @instance
         */
        BingoTeamInfo.prototype.rank = 0;

        /**
         * BingoTeamInfo squares.
         * @member {number} squares
         * @memberof RandoProto.BingoTeamInfo
         * @instance
         */
        BingoTeamInfo.prototype.squares = 0;

        /**
         * BingoTeamInfo lines.
         * @member {number} lines
         * @memberof RandoProto.BingoTeamInfo
         * @instance
         */
        BingoTeamInfo.prototype.lines = 0;

        /**
         * Creates a new BingoTeamInfo instance using the specified properties.
         * @function create
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @param {RandoProto.IBingoTeamInfo=} [properties] Properties to set
         * @returns {RandoProto.BingoTeamInfo} BingoTeamInfo instance
         */
        BingoTeamInfo.create = function create(properties) {
            return new BingoTeamInfo(properties);
        };

        /**
         * Encodes the specified BingoTeamInfo message. Does not implicitly {@link RandoProto.BingoTeamInfo.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @param {RandoProto.IBingoTeamInfo} message BingoTeamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoTeamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.teamId != null && Object.hasOwnProperty.call(message, "teamId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.teamId);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.score);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rank);
            if (message.squares != null && Object.hasOwnProperty.call(message, "squares"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.squares);
            if (message.lines != null && Object.hasOwnProperty.call(message, "lines"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lines);
            return writer;
        };

        /**
         * Encodes the specified BingoTeamInfo message, length delimited. Does not implicitly {@link RandoProto.BingoTeamInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @param {RandoProto.IBingoTeamInfo} message BingoTeamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoTeamInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BingoTeamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.BingoTeamInfo} BingoTeamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoTeamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.BingoTeamInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.teamId = reader.int64();
                    break;
                case 3:
                    message.score = reader.string();
                    break;
                case 4:
                    message.rank = reader.int32();
                    break;
                case 5:
                    message.squares = reader.int32();
                    break;
                case 6:
                    message.lines = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BingoTeamInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.BingoTeamInfo} BingoTeamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoTeamInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BingoTeamInfo message.
         * @function verify
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BingoTeamInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.teamId != null && message.hasOwnProperty("teamId"))
                if (!$util.isInteger(message.teamId) && !(message.teamId && $util.isInteger(message.teamId.low) && $util.isInteger(message.teamId.high)))
                    return "teamId: integer|Long expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isString(message.score))
                    return "score: string expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.squares != null && message.hasOwnProperty("squares"))
                if (!$util.isInteger(message.squares))
                    return "squares: integer expected";
            if (message.lines != null && message.hasOwnProperty("lines"))
                if (!$util.isInteger(message.lines))
                    return "lines: integer expected";
            return null;
        };

        /**
         * Creates a BingoTeamInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.BingoTeamInfo} BingoTeamInfo
         */
        BingoTeamInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.BingoTeamInfo)
                return object;
            let message = new $root.RandoProto.BingoTeamInfo();
            if (object.teamId != null)
                if ($util.Long)
                    (message.teamId = $util.Long.fromValue(object.teamId)).unsigned = false;
                else if (typeof object.teamId === "string")
                    message.teamId = parseInt(object.teamId, 10);
                else if (typeof object.teamId === "number")
                    message.teamId = object.teamId;
                else if (typeof object.teamId === "object")
                    message.teamId = new $util.LongBits(object.teamId.low >>> 0, object.teamId.high >>> 0).toNumber();
            if (object.score != null)
                message.score = String(object.score);
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.squares != null)
                message.squares = object.squares | 0;
            if (object.lines != null)
                message.lines = object.lines | 0;
            return message;
        };

        /**
         * Creates a plain object from a BingoTeamInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @param {RandoProto.BingoTeamInfo} message BingoTeamInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BingoTeamInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.teamId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.teamId = options.longs === String ? "0" : 0;
                object.score = "";
                object.rank = 0;
                object.squares = 0;
                object.lines = 0;
            }
            if (message.teamId != null && message.hasOwnProperty("teamId"))
                if (typeof message.teamId === "number")
                    object.teamId = options.longs === String ? String(message.teamId) : message.teamId;
                else
                    object.teamId = options.longs === String ? $util.Long.prototype.toString.call(message.teamId) : options.longs === Number ? new $util.LongBits(message.teamId.low >>> 0, message.teamId.high >>> 0).toNumber() : message.teamId;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.squares != null && message.hasOwnProperty("squares"))
                object.squares = message.squares;
            if (message.lines != null && message.hasOwnProperty("lines"))
                object.lines = message.lines;
            return object;
        };

        /**
         * Converts this BingoTeamInfo to JSON.
         * @function toJSON
         * @memberof RandoProto.BingoTeamInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BingoTeamInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BingoTeamInfo
         * @function getTypeUrl
         * @memberof RandoProto.BingoTeamInfo
         * @static
         * @returns {string} The default type url
         */
        BingoTeamInfo.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.BingoTeamInfo";
        };

        return BingoTeamInfo;
    })();

    RandoProto.SyncBingoPlayersMessage = (function() {

        /**
         * Properties of a SyncBingoPlayersMessage.
         * @memberof RandoProto
         * @interface ISyncBingoPlayersMessage
         * @property {Array.<RandoProto.IBingoTeamInfo>|null} [players] SyncBingoPlayersMessage players
         */

        /**
         * Constructs a new SyncBingoPlayersMessage.
         * @memberof RandoProto
         * @classdesc Represents a SyncBingoPlayersMessage.
         * @implements ISyncBingoPlayersMessage
         * @constructor
         * @param {RandoProto.ISyncBingoPlayersMessage=} [properties] Properties to set
         */
        function SyncBingoPlayersMessage(properties) {
            this.players = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncBingoPlayersMessage players.
         * @member {Array.<RandoProto.IBingoTeamInfo>} players
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @instance
         */
        SyncBingoPlayersMessage.prototype.players = $util.emptyArray;

        /**
         * Creates a new SyncBingoPlayersMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @param {RandoProto.ISyncBingoPlayersMessage=} [properties] Properties to set
         * @returns {RandoProto.SyncBingoPlayersMessage} SyncBingoPlayersMessage instance
         */
        SyncBingoPlayersMessage.create = function create(properties) {
            return new SyncBingoPlayersMessage(properties);
        };

        /**
         * Encodes the specified SyncBingoPlayersMessage message. Does not implicitly {@link RandoProto.SyncBingoPlayersMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @param {RandoProto.ISyncBingoPlayersMessage} message SyncBingoPlayersMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncBingoPlayersMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.players != null && message.players.length)
                for (let i = 0; i < message.players.length; ++i)
                    $root.RandoProto.BingoTeamInfo.encode(message.players[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncBingoPlayersMessage message, length delimited. Does not implicitly {@link RandoProto.SyncBingoPlayersMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @param {RandoProto.ISyncBingoPlayersMessage} message SyncBingoPlayersMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncBingoPlayersMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncBingoPlayersMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.SyncBingoPlayersMessage} SyncBingoPlayersMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncBingoPlayersMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.SyncBingoPlayersMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.players && message.players.length))
                        message.players = [];
                    message.players.push($root.RandoProto.BingoTeamInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncBingoPlayersMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.SyncBingoPlayersMessage} SyncBingoPlayersMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncBingoPlayersMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncBingoPlayersMessage message.
         * @function verify
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncBingoPlayersMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.players != null && message.hasOwnProperty("players")) {
                if (!Array.isArray(message.players))
                    return "players: array expected";
                for (let i = 0; i < message.players.length; ++i) {
                    let error = $root.RandoProto.BingoTeamInfo.verify(message.players[i]);
                    if (error)
                        return "players." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SyncBingoPlayersMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.SyncBingoPlayersMessage} SyncBingoPlayersMessage
         */
        SyncBingoPlayersMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.SyncBingoPlayersMessage)
                return object;
            let message = new $root.RandoProto.SyncBingoPlayersMessage();
            if (object.players) {
                if (!Array.isArray(object.players))
                    throw TypeError(".RandoProto.SyncBingoPlayersMessage.players: array expected");
                message.players = [];
                for (let i = 0; i < object.players.length; ++i) {
                    if (typeof object.players[i] !== "object")
                        throw TypeError(".RandoProto.SyncBingoPlayersMessage.players: object expected");
                    message.players[i] = $root.RandoProto.BingoTeamInfo.fromObject(object.players[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncBingoPlayersMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @param {RandoProto.SyncBingoPlayersMessage} message SyncBingoPlayersMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncBingoPlayersMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.players = [];
            if (message.players && message.players.length) {
                object.players = [];
                for (let j = 0; j < message.players.length; ++j)
                    object.players[j] = $root.RandoProto.BingoTeamInfo.toObject(message.players[j], options);
            }
            return object;
        };

        /**
         * Converts this SyncBingoPlayersMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncBingoPlayersMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncBingoPlayersMessage
         * @function getTypeUrl
         * @memberof RandoProto.SyncBingoPlayersMessage
         * @static
         * @returns {string} The default type url
         */
        SyncBingoPlayersMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.SyncBingoPlayersMessage";
        };

        return SyncBingoPlayersMessage;
    })();

    RandoProto.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof RandoProto
         * @interface IPosition
         * @property {number|null} [x] Position x
         * @property {number|null} [y] Position y
         */

        /**
         * Constructs a new Position.
         * @memberof RandoProto
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {RandoProto.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position x.
         * @member {number} x
         * @memberof RandoProto.Position
         * @instance
         */
        Position.prototype.x = 0;

        /**
         * Position y.
         * @member {number} y
         * @memberof RandoProto.Position
         * @instance
         */
        Position.prototype.y = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof RandoProto.Position
         * @static
         * @param {RandoProto.IPosition=} [properties] Properties to set
         * @returns {RandoProto.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link RandoProto.Position.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.Position
         * @static
         * @param {RandoProto.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link RandoProto.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.Position
         * @static
         * @param {RandoProto.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.Position();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof RandoProto.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.Position)
                return object;
            let message = new $root.RandoProto.Position();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.Position
         * @static
         * @param {RandoProto.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof RandoProto.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Position
         * @function getTypeUrl
         * @memberof RandoProto.Position
         * @static
         * @returns {string} The default type url
         */
        Position.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.Position";
        };

        return Position;
    })();

    RandoProto.PositionedBingoSquare = (function() {

        /**
         * Properties of a PositionedBingoSquare.
         * @memberof RandoProto
         * @interface IPositionedBingoSquare
         * @property {RandoProto.IPosition|null} [position] PositionedBingoSquare position
         * @property {RandoProto.IBingoSquare|null} [square] PositionedBingoSquare square
         */

        /**
         * Constructs a new PositionedBingoSquare.
         * @memberof RandoProto
         * @classdesc Represents a PositionedBingoSquare.
         * @implements IPositionedBingoSquare
         * @constructor
         * @param {RandoProto.IPositionedBingoSquare=} [properties] Properties to set
         */
        function PositionedBingoSquare(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PositionedBingoSquare position.
         * @member {RandoProto.IPosition|null|undefined} position
         * @memberof RandoProto.PositionedBingoSquare
         * @instance
         */
        PositionedBingoSquare.prototype.position = null;

        /**
         * PositionedBingoSquare square.
         * @member {RandoProto.IBingoSquare|null|undefined} square
         * @memberof RandoProto.PositionedBingoSquare
         * @instance
         */
        PositionedBingoSquare.prototype.square = null;

        /**
         * Creates a new PositionedBingoSquare instance using the specified properties.
         * @function create
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {RandoProto.IPositionedBingoSquare=} [properties] Properties to set
         * @returns {RandoProto.PositionedBingoSquare} PositionedBingoSquare instance
         */
        PositionedBingoSquare.create = function create(properties) {
            return new PositionedBingoSquare(properties);
        };

        /**
         * Encodes the specified PositionedBingoSquare message. Does not implicitly {@link RandoProto.PositionedBingoSquare.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {RandoProto.IPositionedBingoSquare} message PositionedBingoSquare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionedBingoSquare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.RandoProto.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.square != null && Object.hasOwnProperty.call(message, "square"))
                $root.RandoProto.BingoSquare.encode(message.square, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PositionedBingoSquare message, length delimited. Does not implicitly {@link RandoProto.PositionedBingoSquare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {RandoProto.IPositionedBingoSquare} message PositionedBingoSquare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionedBingoSquare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PositionedBingoSquare message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.PositionedBingoSquare} PositionedBingoSquare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionedBingoSquare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.PositionedBingoSquare();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = $root.RandoProto.Position.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.square = $root.RandoProto.BingoSquare.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PositionedBingoSquare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.PositionedBingoSquare} PositionedBingoSquare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionedBingoSquare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PositionedBingoSquare message.
         * @function verify
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PositionedBingoSquare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                let error = $root.RandoProto.Position.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.square != null && message.hasOwnProperty("square")) {
                let error = $root.RandoProto.BingoSquare.verify(message.square);
                if (error)
                    return "square." + error;
            }
            return null;
        };

        /**
         * Creates a PositionedBingoSquare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.PositionedBingoSquare} PositionedBingoSquare
         */
        PositionedBingoSquare.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.PositionedBingoSquare)
                return object;
            let message = new $root.RandoProto.PositionedBingoSquare();
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".RandoProto.PositionedBingoSquare.position: object expected");
                message.position = $root.RandoProto.Position.fromObject(object.position);
            }
            if (object.square != null) {
                if (typeof object.square !== "object")
                    throw TypeError(".RandoProto.PositionedBingoSquare.square: object expected");
                message.square = $root.RandoProto.BingoSquare.fromObject(object.square);
            }
            return message;
        };

        /**
         * Creates a plain object from a PositionedBingoSquare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {RandoProto.PositionedBingoSquare} message PositionedBingoSquare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PositionedBingoSquare.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.position = null;
                object.square = null;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.RandoProto.Position.toObject(message.position, options);
            if (message.square != null && message.hasOwnProperty("square"))
                object.square = $root.RandoProto.BingoSquare.toObject(message.square, options);
            return object;
        };

        /**
         * Converts this PositionedBingoSquare to JSON.
         * @function toJSON
         * @memberof RandoProto.PositionedBingoSquare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PositionedBingoSquare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PositionedBingoSquare
         * @function getTypeUrl
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @returns {string} The default type url
         */
        PositionedBingoSquare.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.PositionedBingoSquare";
        };

        return PositionedBingoSquare;
    })();

    RandoProto.BingoBoard = (function() {

        /**
         * Properties of a BingoBoard.
         * @memberof RandoProto
         * @interface IBingoBoard
         * @property {Array.<RandoProto.IPositionedBingoSquare>|null} [squares] BingoBoard squares
         * @property {number|null} [size] BingoBoard size
         */

        /**
         * Constructs a new BingoBoard.
         * @memberof RandoProto
         * @classdesc Represents a BingoBoard.
         * @implements IBingoBoard
         * @constructor
         * @param {RandoProto.IBingoBoard=} [properties] Properties to set
         */
        function BingoBoard(properties) {
            this.squares = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BingoBoard squares.
         * @member {Array.<RandoProto.IPositionedBingoSquare>} squares
         * @memberof RandoProto.BingoBoard
         * @instance
         */
        BingoBoard.prototype.squares = $util.emptyArray;

        /**
         * BingoBoard size.
         * @member {number} size
         * @memberof RandoProto.BingoBoard
         * @instance
         */
        BingoBoard.prototype.size = 0;

        /**
         * Creates a new BingoBoard instance using the specified properties.
         * @function create
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {RandoProto.IBingoBoard=} [properties] Properties to set
         * @returns {RandoProto.BingoBoard} BingoBoard instance
         */
        BingoBoard.create = function create(properties) {
            return new BingoBoard(properties);
        };

        /**
         * Encodes the specified BingoBoard message. Does not implicitly {@link RandoProto.BingoBoard.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {RandoProto.IBingoBoard} message BingoBoard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoBoard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.squares != null && message.squares.length)
                for (let i = 0; i < message.squares.length; ++i)
                    $root.RandoProto.PositionedBingoSquare.encode(message.squares[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.size);
            return writer;
        };

        /**
         * Encodes the specified BingoBoard message, length delimited. Does not implicitly {@link RandoProto.BingoBoard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {RandoProto.IBingoBoard} message BingoBoard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoBoard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BingoBoard message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.BingoBoard} BingoBoard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoBoard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.BingoBoard();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.squares && message.squares.length))
                        message.squares = [];
                    message.squares.push($root.RandoProto.PositionedBingoSquare.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.size = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BingoBoard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.BingoBoard} BingoBoard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoBoard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BingoBoard message.
         * @function verify
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BingoBoard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.squares != null && message.hasOwnProperty("squares")) {
                if (!Array.isArray(message.squares))
                    return "squares: array expected";
                for (let i = 0; i < message.squares.length; ++i) {
                    let error = $root.RandoProto.PositionedBingoSquare.verify(message.squares[i]);
                    if (error)
                        return "squares." + error;
                }
            }
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            return null;
        };

        /**
         * Creates a BingoBoard message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.BingoBoard} BingoBoard
         */
        BingoBoard.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.BingoBoard)
                return object;
            let message = new $root.RandoProto.BingoBoard();
            if (object.squares) {
                if (!Array.isArray(object.squares))
                    throw TypeError(".RandoProto.BingoBoard.squares: array expected");
                message.squares = [];
                for (let i = 0; i < object.squares.length; ++i) {
                    if (typeof object.squares[i] !== "object")
                        throw TypeError(".RandoProto.BingoBoard.squares: object expected");
                    message.squares[i] = $root.RandoProto.PositionedBingoSquare.fromObject(object.squares[i]);
                }
            }
            if (object.size != null)
                message.size = object.size | 0;
            return message;
        };

        /**
         * Creates a plain object from a BingoBoard message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {RandoProto.BingoBoard} message BingoBoard
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BingoBoard.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.squares = [];
            if (options.defaults)
                object.size = 0;
            if (message.squares && message.squares.length) {
                object.squares = [];
                for (let j = 0; j < message.squares.length; ++j)
                    object.squares[j] = $root.RandoProto.PositionedBingoSquare.toObject(message.squares[j], options);
            }
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            return object;
        };

        /**
         * Converts this BingoBoard to JSON.
         * @function toJSON
         * @memberof RandoProto.BingoBoard
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BingoBoard.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BingoBoard
         * @function getTypeUrl
         * @memberof RandoProto.BingoBoard
         * @static
         * @returns {string} The default type url
         */
        BingoBoard.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.BingoBoard";
        };

        return BingoBoard;
    })();

    RandoProto.SyncBoardMessage = (function() {

        /**
         * Properties of a SyncBoardMessage.
         * @memberof RandoProto
         * @interface ISyncBoardMessage
         * @property {RandoProto.IBingoBoard|null} [board] SyncBoardMessage board
         * @property {boolean|null} [replace] SyncBoardMessage replace
         */

        /**
         * Constructs a new SyncBoardMessage.
         * @memberof RandoProto
         * @classdesc Represents a SyncBoardMessage.
         * @implements ISyncBoardMessage
         * @constructor
         * @param {RandoProto.ISyncBoardMessage=} [properties] Properties to set
         */
        function SyncBoardMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncBoardMessage board.
         * @member {RandoProto.IBingoBoard|null|undefined} board
         * @memberof RandoProto.SyncBoardMessage
         * @instance
         */
        SyncBoardMessage.prototype.board = null;

        /**
         * SyncBoardMessage replace.
         * @member {boolean} replace
         * @memberof RandoProto.SyncBoardMessage
         * @instance
         */
        SyncBoardMessage.prototype.replace = false;

        /**
         * Creates a new SyncBoardMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {RandoProto.ISyncBoardMessage=} [properties] Properties to set
         * @returns {RandoProto.SyncBoardMessage} SyncBoardMessage instance
         */
        SyncBoardMessage.create = function create(properties) {
            return new SyncBoardMessage(properties);
        };

        /**
         * Encodes the specified SyncBoardMessage message. Does not implicitly {@link RandoProto.SyncBoardMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {RandoProto.ISyncBoardMessage} message SyncBoardMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncBoardMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.board != null && Object.hasOwnProperty.call(message, "board"))
                $root.RandoProto.BingoBoard.encode(message.board, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.replace != null && Object.hasOwnProperty.call(message, "replace"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.replace);
            return writer;
        };

        /**
         * Encodes the specified SyncBoardMessage message, length delimited. Does not implicitly {@link RandoProto.SyncBoardMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {RandoProto.ISyncBoardMessage} message SyncBoardMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncBoardMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncBoardMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.SyncBoardMessage} SyncBoardMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncBoardMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.SyncBoardMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.board = $root.RandoProto.BingoBoard.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.replace = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncBoardMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.SyncBoardMessage} SyncBoardMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncBoardMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncBoardMessage message.
         * @function verify
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncBoardMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.board != null && message.hasOwnProperty("board")) {
                let error = $root.RandoProto.BingoBoard.verify(message.board);
                if (error)
                    return "board." + error;
            }
            if (message.replace != null && message.hasOwnProperty("replace"))
                if (typeof message.replace !== "boolean")
                    return "replace: boolean expected";
            return null;
        };

        /**
         * Creates a SyncBoardMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.SyncBoardMessage} SyncBoardMessage
         */
        SyncBoardMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.SyncBoardMessage)
                return object;
            let message = new $root.RandoProto.SyncBoardMessage();
            if (object.board != null) {
                if (typeof object.board !== "object")
                    throw TypeError(".RandoProto.SyncBoardMessage.board: object expected");
                message.board = $root.RandoProto.BingoBoard.fromObject(object.board);
            }
            if (object.replace != null)
                message.replace = Boolean(object.replace);
            return message;
        };

        /**
         * Creates a plain object from a SyncBoardMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {RandoProto.SyncBoardMessage} message SyncBoardMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncBoardMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.board = null;
                object.replace = false;
            }
            if (message.board != null && message.hasOwnProperty("board"))
                object.board = $root.RandoProto.BingoBoard.toObject(message.board, options);
            if (message.replace != null && message.hasOwnProperty("replace"))
                object.replace = message.replace;
            return object;
        };

        /**
         * Converts this SyncBoardMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.SyncBoardMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncBoardMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncBoardMessage
         * @function getTypeUrl
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @returns {string} The default type url
         */
        SyncBoardMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.SyncBoardMessage";
        };

        return SyncBoardMessage;
    })();

    return RandoProto;
})();
