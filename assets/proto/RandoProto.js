/* eslint-disable */
import $protobuf from 'protobufjs'

// THIS IS AN AUTOGENERATED FILE
// DO NOT EDIT!

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const RandoProto = $root.RandoProto = (() => {

    /**
     * Namespace RandoProto.
     * @exports RandoProto
     * @namespace
     */
    const RandoProto = {};

    RandoProto.Packet = (function() {

        /**
         * Properties of a Packet.
         * @memberof RandoProto
         * @interface IPacket
         * @property {number|null} [id] Packet id
         * @property {Uint8Array|null} [packet] Packet packet
         */

        /**
         * Constructs a new Packet.
         * @memberof RandoProto
         * @classdesc Represents a Packet.
         * @implements IPacket
         * @constructor
         * @param {RandoProto.IPacket=} [properties] Properties to set
         */
        function Packet(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Packet id.
         * @member {number} id
         * @memberof RandoProto.Packet
         * @instance
         */
        Packet.prototype.id = 0;

        /**
         * Packet packet.
         * @member {Uint8Array} packet
         * @memberof RandoProto.Packet
         * @instance
         */
        Packet.prototype.packet = $util.newBuffer([]);

        /**
         * Creates a new Packet instance using the specified properties.
         * @function create
         * @memberof RandoProto.Packet
         * @static
         * @param {RandoProto.IPacket=} [properties] Properties to set
         * @returns {RandoProto.Packet} Packet instance
         */
        Packet.create = function create(properties) {
            return new Packet(properties);
        };

        /**
         * Encodes the specified Packet message. Does not implicitly {@link RandoProto.Packet.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.Packet
         * @static
         * @param {RandoProto.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.packet != null && Object.hasOwnProperty.call(message, "packet"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.packet);
            return writer;
        };

        /**
         * Encodes the specified Packet message, length delimited. Does not implicitly {@link RandoProto.Packet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.Packet
         * @static
         * @param {RandoProto.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Packet message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.Packet();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.packet = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Packet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Packet message.
         * @function verify
         * @memberof RandoProto.Packet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Packet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.packet != null && message.hasOwnProperty("packet"))
                if (!(message.packet && typeof message.packet.length === "number" || $util.isString(message.packet)))
                    return "packet: buffer expected";
            return null;
        };

        /**
         * Creates a Packet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.Packet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.Packet} Packet
         */
        Packet.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.Packet)
                return object;
            let message = new $root.RandoProto.Packet();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.packet != null)
                if (typeof object.packet === "string")
                    $util.base64.decode(object.packet, message.packet = $util.newBuffer($util.base64.length(object.packet)), 0);
                else if (object.packet.length)
                    message.packet = object.packet;
            return message;
        };

        /**
         * Creates a plain object from a Packet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.Packet
         * @static
         * @param {RandoProto.Packet} message Packet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Packet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                if (options.bytes === String)
                    object.packet = "";
                else {
                    object.packet = [];
                    if (options.bytes !== Array)
                        object.packet = $util.newBuffer(object.packet);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.packet != null && message.hasOwnProperty("packet"))
                object.packet = options.bytes === String ? $util.base64.encode(message.packet, 0, message.packet.length) : options.bytes === Array ? Array.prototype.slice.call(message.packet) : message.packet;
            return object;
        };

        /**
         * Converts this Packet to JSON.
         * @function toJSON
         * @memberof RandoProto.Packet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Packet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Packet
         * @function getTypeUrl
         * @memberof RandoProto.Packet
         * @static
         * @returns {string} The default type url
         */
        Packet.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.Packet";
        };

        return Packet;
    })();

    RandoProto.BingoGoal = (function() {

        /**
         * Properties of a BingoGoal.
         * @memberof RandoProto
         * @interface IBingoGoal
         * @property {string|null} [text] BingoGoal text
         * @property {boolean|null} [completed] BingoGoal completed
         */

        /**
         * Constructs a new BingoGoal.
         * @memberof RandoProto
         * @classdesc Represents a BingoGoal.
         * @implements IBingoGoal
         * @constructor
         * @param {RandoProto.IBingoGoal=} [properties] Properties to set
         */
        function BingoGoal(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BingoGoal text.
         * @member {string} text
         * @memberof RandoProto.BingoGoal
         * @instance
         */
        BingoGoal.prototype.text = "";

        /**
         * BingoGoal completed.
         * @member {boolean} completed
         * @memberof RandoProto.BingoGoal
         * @instance
         */
        BingoGoal.prototype.completed = false;

        /**
         * Creates a new BingoGoal instance using the specified properties.
         * @function create
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {RandoProto.IBingoGoal=} [properties] Properties to set
         * @returns {RandoProto.BingoGoal} BingoGoal instance
         */
        BingoGoal.create = function create(properties) {
            return new BingoGoal(properties);
        };

        /**
         * Encodes the specified BingoGoal message. Does not implicitly {@link RandoProto.BingoGoal.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {RandoProto.IBingoGoal} message BingoGoal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoGoal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.completed != null && Object.hasOwnProperty.call(message, "completed"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.completed);
            return writer;
        };

        /**
         * Encodes the specified BingoGoal message, length delimited. Does not implicitly {@link RandoProto.BingoGoal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {RandoProto.IBingoGoal} message BingoGoal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoGoal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BingoGoal message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.BingoGoal} BingoGoal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoGoal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.BingoGoal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.completed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BingoGoal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.BingoGoal} BingoGoal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoGoal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BingoGoal message.
         * @function verify
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BingoGoal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.completed != null && message.hasOwnProperty("completed"))
                if (typeof message.completed !== "boolean")
                    return "completed: boolean expected";
            return null;
        };

        /**
         * Creates a BingoGoal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.BingoGoal} BingoGoal
         */
        BingoGoal.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.BingoGoal)
                return object;
            let message = new $root.RandoProto.BingoGoal();
            if (object.text != null)
                message.text = String(object.text);
            if (object.completed != null)
                message.completed = Boolean(object.completed);
            return message;
        };

        /**
         * Creates a plain object from a BingoGoal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.BingoGoal
         * @static
         * @param {RandoProto.BingoGoal} message BingoGoal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BingoGoal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.text = "";
                object.completed = false;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.completed != null && message.hasOwnProperty("completed"))
                object.completed = message.completed;
            return object;
        };

        /**
         * Converts this BingoGoal to JSON.
         * @function toJSON
         * @memberof RandoProto.BingoGoal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BingoGoal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BingoGoal
         * @function getTypeUrl
         * @memberof RandoProto.BingoGoal
         * @static
         * @returns {string} The default type url
         */
        BingoGoal.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.BingoGoal";
        };

        return BingoGoal;
    })();

    RandoProto.UserInfo = (function() {

        /**
         * Properties of a UserInfo.
         * @memberof RandoProto
         * @interface IUserInfo
         * @property {string|null} [id] UserInfo id
         * @property {string|null} [name] UserInfo name
         * @property {string|null} [avatarId] UserInfo avatarId
         */

        /**
         * Constructs a new UserInfo.
         * @memberof RandoProto
         * @classdesc Represents a UserInfo.
         * @implements IUserInfo
         * @constructor
         * @param {RandoProto.IUserInfo=} [properties] Properties to set
         */
        function UserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfo id.
         * @member {string} id
         * @memberof RandoProto.UserInfo
         * @instance
         */
        UserInfo.prototype.id = "";

        /**
         * UserInfo name.
         * @member {string} name
         * @memberof RandoProto.UserInfo
         * @instance
         */
        UserInfo.prototype.name = "";

        /**
         * UserInfo avatarId.
         * @member {string|null|undefined} avatarId
         * @memberof RandoProto.UserInfo
         * @instance
         */
        UserInfo.prototype.avatarId = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * UserInfo _avatarId.
         * @member {"avatarId"|undefined} _avatarId
         * @memberof RandoProto.UserInfo
         * @instance
         */
        Object.defineProperty(UserInfo.prototype, "_avatarId", {
            get: $util.oneOfGetter($oneOfFields = ["avatarId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new UserInfo instance using the specified properties.
         * @function create
         * @memberof RandoProto.UserInfo
         * @static
         * @param {RandoProto.IUserInfo=} [properties] Properties to set
         * @returns {RandoProto.UserInfo} UserInfo instance
         */
        UserInfo.create = function create(properties) {
            return new UserInfo(properties);
        };

        /**
         * Encodes the specified UserInfo message. Does not implicitly {@link RandoProto.UserInfo.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.UserInfo
         * @static
         * @param {RandoProto.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarId);
            return writer;
        };

        /**
         * Encodes the specified UserInfo message, length delimited. Does not implicitly {@link RandoProto.UserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.UserInfo
         * @static
         * @param {RandoProto.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.UserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatarId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserInfo message.
         * @function verify
         * @memberof RandoProto.UserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId")) {
                properties._avatarId = 1;
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            }
            return null;
        };

        /**
         * Creates a UserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.UserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.UserInfo} UserInfo
         */
        UserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.UserInfo)
                return object;
            let message = new $root.RandoProto.UserInfo();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            return message;
        };

        /**
         * Creates a plain object from a UserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.UserInfo
         * @static
         * @param {RandoProto.UserInfo} message UserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId")) {
                object.avatarId = message.avatarId;
                if (options.oneofs)
                    object._avatarId = "avatarId";
            }
            return object;
        };

        /**
         * Converts this UserInfo to JSON.
         * @function toJSON
         * @memberof RandoProto.UserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserInfo
         * @function getTypeUrl
         * @memberof RandoProto.UserInfo
         * @static
         * @returns {string} The default type url
         */
        UserInfo.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.UserInfo";
        };

        return UserInfo;
    })();

    RandoProto.WorldInfo = (function() {

        /**
         * Properties of a WorldInfo.
         * @memberof RandoProto
         * @interface IWorldInfo
         * @property {number|Long|null} [id] WorldInfo id
         * @property {string|null} [name] WorldInfo name
         * @property {Array.<RandoProto.IUserInfo>|null} [members] WorldInfo members
         */

        /**
         * Constructs a new WorldInfo.
         * @memberof RandoProto
         * @classdesc Represents a WorldInfo.
         * @implements IWorldInfo
         * @constructor
         * @param {RandoProto.IWorldInfo=} [properties] Properties to set
         */
        function WorldInfo(properties) {
            this.members = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WorldInfo id.
         * @member {number|Long} id
         * @memberof RandoProto.WorldInfo
         * @instance
         */
        WorldInfo.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WorldInfo name.
         * @member {string} name
         * @memberof RandoProto.WorldInfo
         * @instance
         */
        WorldInfo.prototype.name = "";

        /**
         * WorldInfo members.
         * @member {Array.<RandoProto.IUserInfo>} members
         * @memberof RandoProto.WorldInfo
         * @instance
         */
        WorldInfo.prototype.members = $util.emptyArray;

        /**
         * Creates a new WorldInfo instance using the specified properties.
         * @function create
         * @memberof RandoProto.WorldInfo
         * @static
         * @param {RandoProto.IWorldInfo=} [properties] Properties to set
         * @returns {RandoProto.WorldInfo} WorldInfo instance
         */
        WorldInfo.create = function create(properties) {
            return new WorldInfo(properties);
        };

        /**
         * Encodes the specified WorldInfo message. Does not implicitly {@link RandoProto.WorldInfo.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.WorldInfo
         * @static
         * @param {RandoProto.IWorldInfo} message WorldInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.members != null && message.members.length)
                for (let i = 0; i < message.members.length; ++i)
                    $root.RandoProto.UserInfo.encode(message.members[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WorldInfo message, length delimited. Does not implicitly {@link RandoProto.WorldInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.WorldInfo
         * @static
         * @param {RandoProto.IWorldInfo} message WorldInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WorldInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.WorldInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.WorldInfo} WorldInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.WorldInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.RandoProto.UserInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WorldInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.WorldInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.WorldInfo} WorldInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WorldInfo message.
         * @function verify
         * @memberof RandoProto.WorldInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WorldInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (let i = 0; i < message.members.length; ++i) {
                    let error = $root.RandoProto.UserInfo.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WorldInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.WorldInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.WorldInfo} WorldInfo
         */
        WorldInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.WorldInfo)
                return object;
            let message = new $root.RandoProto.WorldInfo();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".RandoProto.WorldInfo.members: array expected");
                message.members = [];
                for (let i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".RandoProto.WorldInfo.members: object expected");
                    message.members[i] = $root.RandoProto.UserInfo.fromObject(object.members[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WorldInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.WorldInfo
         * @static
         * @param {RandoProto.WorldInfo} message WorldInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WorldInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.members && message.members.length) {
                object.members = [];
                for (let j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.RandoProto.UserInfo.toObject(message.members[j], options);
            }
            return object;
        };

        /**
         * Converts this WorldInfo to JSON.
         * @function toJSON
         * @memberof RandoProto.WorldInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WorldInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WorldInfo
         * @function getTypeUrl
         * @memberof RandoProto.WorldInfo
         * @static
         * @returns {string} The default type url
         */
        WorldInfo.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.WorldInfo";
        };

        return WorldInfo;
    })();

    RandoProto.UniverseInfo = (function() {

        /**
         * Properties of an UniverseInfo.
         * @memberof RandoProto
         * @interface IUniverseInfo
         * @property {number|Long|null} [id] UniverseInfo id
         * @property {string|null} [name] UniverseInfo name
         * @property {Array.<RandoProto.IWorldInfo>|null} [worlds] UniverseInfo worlds
         */

        /**
         * Constructs a new UniverseInfo.
         * @memberof RandoProto
         * @classdesc Represents an UniverseInfo.
         * @implements IUniverseInfo
         * @constructor
         * @param {RandoProto.IUniverseInfo=} [properties] Properties to set
         */
        function UniverseInfo(properties) {
            this.worlds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UniverseInfo id.
         * @member {number|Long} id
         * @memberof RandoProto.UniverseInfo
         * @instance
         */
        UniverseInfo.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UniverseInfo name.
         * @member {string} name
         * @memberof RandoProto.UniverseInfo
         * @instance
         */
        UniverseInfo.prototype.name = "";

        /**
         * UniverseInfo worlds.
         * @member {Array.<RandoProto.IWorldInfo>} worlds
         * @memberof RandoProto.UniverseInfo
         * @instance
         */
        UniverseInfo.prototype.worlds = $util.emptyArray;

        /**
         * Creates a new UniverseInfo instance using the specified properties.
         * @function create
         * @memberof RandoProto.UniverseInfo
         * @static
         * @param {RandoProto.IUniverseInfo=} [properties] Properties to set
         * @returns {RandoProto.UniverseInfo} UniverseInfo instance
         */
        UniverseInfo.create = function create(properties) {
            return new UniverseInfo(properties);
        };

        /**
         * Encodes the specified UniverseInfo message. Does not implicitly {@link RandoProto.UniverseInfo.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.UniverseInfo
         * @static
         * @param {RandoProto.IUniverseInfo} message UniverseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UniverseInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.worlds != null && message.worlds.length)
                for (let i = 0; i < message.worlds.length; ++i)
                    $root.RandoProto.WorldInfo.encode(message.worlds[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UniverseInfo message, length delimited. Does not implicitly {@link RandoProto.UniverseInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.UniverseInfo
         * @static
         * @param {RandoProto.IUniverseInfo} message UniverseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UniverseInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UniverseInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.UniverseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.UniverseInfo} UniverseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UniverseInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.UniverseInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.worlds && message.worlds.length))
                        message.worlds = [];
                    message.worlds.push($root.RandoProto.WorldInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UniverseInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.UniverseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.UniverseInfo} UniverseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UniverseInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UniverseInfo message.
         * @function verify
         * @memberof RandoProto.UniverseInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UniverseInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.worlds != null && message.hasOwnProperty("worlds")) {
                if (!Array.isArray(message.worlds))
                    return "worlds: array expected";
                for (let i = 0; i < message.worlds.length; ++i) {
                    let error = $root.RandoProto.WorldInfo.verify(message.worlds[i]);
                    if (error)
                        return "worlds." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UniverseInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.UniverseInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.UniverseInfo} UniverseInfo
         */
        UniverseInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.UniverseInfo)
                return object;
            let message = new $root.RandoProto.UniverseInfo();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.worlds) {
                if (!Array.isArray(object.worlds))
                    throw TypeError(".RandoProto.UniverseInfo.worlds: array expected");
                message.worlds = [];
                for (let i = 0; i < object.worlds.length; ++i) {
                    if (typeof object.worlds[i] !== "object")
                        throw TypeError(".RandoProto.UniverseInfo.worlds: object expected");
                    message.worlds[i] = $root.RandoProto.WorldInfo.fromObject(object.worlds[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UniverseInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.UniverseInfo
         * @static
         * @param {RandoProto.UniverseInfo} message UniverseInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UniverseInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.worlds = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.worlds && message.worlds.length) {
                object.worlds = [];
                for (let j = 0; j < message.worlds.length; ++j)
                    object.worlds[j] = $root.RandoProto.WorldInfo.toObject(message.worlds[j], options);
            }
            return object;
        };

        /**
         * Converts this UniverseInfo to JSON.
         * @function toJSON
         * @memberof RandoProto.UniverseInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UniverseInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UniverseInfo
         * @function getTypeUrl
         * @memberof RandoProto.UniverseInfo
         * @static
         * @returns {string} The default type url
         */
        UniverseInfo.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.UniverseInfo";
        };

        return UniverseInfo;
    })();

    RandoProto.MultiverseInfoMessage = (function() {

        /**
         * Properties of a MultiverseInfoMessage.
         * @memberof RandoProto
         * @interface IMultiverseInfoMessage
         * @property {number|Long|null} [id] MultiverseInfoMessage id
         * @property {Array.<RandoProto.IUniverseInfo>|null} [universes] MultiverseInfoMessage universes
         * @property {boolean|null} [hasBingoBoard] MultiverseInfoMessage hasBingoBoard
         * @property {Array.<RandoProto.IUserInfo>|null} [spectators] MultiverseInfoMessage spectators
         */

        /**
         * Constructs a new MultiverseInfoMessage.
         * @memberof RandoProto
         * @classdesc Represents a MultiverseInfoMessage.
         * @implements IMultiverseInfoMessage
         * @constructor
         * @param {RandoProto.IMultiverseInfoMessage=} [properties] Properties to set
         */
        function MultiverseInfoMessage(properties) {
            this.universes = [];
            this.spectators = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MultiverseInfoMessage id.
         * @member {number|Long} id
         * @memberof RandoProto.MultiverseInfoMessage
         * @instance
         */
        MultiverseInfoMessage.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MultiverseInfoMessage universes.
         * @member {Array.<RandoProto.IUniverseInfo>} universes
         * @memberof RandoProto.MultiverseInfoMessage
         * @instance
         */
        MultiverseInfoMessage.prototype.universes = $util.emptyArray;

        /**
         * MultiverseInfoMessage hasBingoBoard.
         * @member {boolean} hasBingoBoard
         * @memberof RandoProto.MultiverseInfoMessage
         * @instance
         */
        MultiverseInfoMessage.prototype.hasBingoBoard = false;

        /**
         * MultiverseInfoMessage spectators.
         * @member {Array.<RandoProto.IUserInfo>} spectators
         * @memberof RandoProto.MultiverseInfoMessage
         * @instance
         */
        MultiverseInfoMessage.prototype.spectators = $util.emptyArray;

        /**
         * Creates a new MultiverseInfoMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @param {RandoProto.IMultiverseInfoMessage=} [properties] Properties to set
         * @returns {RandoProto.MultiverseInfoMessage} MultiverseInfoMessage instance
         */
        MultiverseInfoMessage.create = function create(properties) {
            return new MultiverseInfoMessage(properties);
        };

        /**
         * Encodes the specified MultiverseInfoMessage message. Does not implicitly {@link RandoProto.MultiverseInfoMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @param {RandoProto.IMultiverseInfoMessage} message MultiverseInfoMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiverseInfoMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.universes != null && message.universes.length)
                for (let i = 0; i < message.universes.length; ++i)
                    $root.RandoProto.UniverseInfo.encode(message.universes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hasBingoBoard != null && Object.hasOwnProperty.call(message, "hasBingoBoard"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasBingoBoard);
            if (message.spectators != null && message.spectators.length)
                for (let i = 0; i < message.spectators.length; ++i)
                    $root.RandoProto.UserInfo.encode(message.spectators[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MultiverseInfoMessage message, length delimited. Does not implicitly {@link RandoProto.MultiverseInfoMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @param {RandoProto.IMultiverseInfoMessage} message MultiverseInfoMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiverseInfoMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MultiverseInfoMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.MultiverseInfoMessage} MultiverseInfoMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiverseInfoMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.MultiverseInfoMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    if (!(message.universes && message.universes.length))
                        message.universes = [];
                    message.universes.push($root.RandoProto.UniverseInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.hasBingoBoard = reader.bool();
                    break;
                case 4:
                    if (!(message.spectators && message.spectators.length))
                        message.spectators = [];
                    message.spectators.push($root.RandoProto.UserInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MultiverseInfoMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.MultiverseInfoMessage} MultiverseInfoMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiverseInfoMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MultiverseInfoMessage message.
         * @function verify
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MultiverseInfoMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.universes != null && message.hasOwnProperty("universes")) {
                if (!Array.isArray(message.universes))
                    return "universes: array expected";
                for (let i = 0; i < message.universes.length; ++i) {
                    let error = $root.RandoProto.UniverseInfo.verify(message.universes[i]);
                    if (error)
                        return "universes." + error;
                }
            }
            if (message.hasBingoBoard != null && message.hasOwnProperty("hasBingoBoard"))
                if (typeof message.hasBingoBoard !== "boolean")
                    return "hasBingoBoard: boolean expected";
            if (message.spectators != null && message.hasOwnProperty("spectators")) {
                if (!Array.isArray(message.spectators))
                    return "spectators: array expected";
                for (let i = 0; i < message.spectators.length; ++i) {
                    let error = $root.RandoProto.UserInfo.verify(message.spectators[i]);
                    if (error)
                        return "spectators." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MultiverseInfoMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.MultiverseInfoMessage} MultiverseInfoMessage
         */
        MultiverseInfoMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.MultiverseInfoMessage)
                return object;
            let message = new $root.RandoProto.MultiverseInfoMessage();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.universes) {
                if (!Array.isArray(object.universes))
                    throw TypeError(".RandoProto.MultiverseInfoMessage.universes: array expected");
                message.universes = [];
                for (let i = 0; i < object.universes.length; ++i) {
                    if (typeof object.universes[i] !== "object")
                        throw TypeError(".RandoProto.MultiverseInfoMessage.universes: object expected");
                    message.universes[i] = $root.RandoProto.UniverseInfo.fromObject(object.universes[i]);
                }
            }
            if (object.hasBingoBoard != null)
                message.hasBingoBoard = Boolean(object.hasBingoBoard);
            if (object.spectators) {
                if (!Array.isArray(object.spectators))
                    throw TypeError(".RandoProto.MultiverseInfoMessage.spectators: array expected");
                message.spectators = [];
                for (let i = 0; i < object.spectators.length; ++i) {
                    if (typeof object.spectators[i] !== "object")
                        throw TypeError(".RandoProto.MultiverseInfoMessage.spectators: object expected");
                    message.spectators[i] = $root.RandoProto.UserInfo.fromObject(object.spectators[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MultiverseInfoMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @param {RandoProto.MultiverseInfoMessage} message MultiverseInfoMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MultiverseInfoMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.universes = [];
                object.spectators = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.hasBingoBoard = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.universes && message.universes.length) {
                object.universes = [];
                for (let j = 0; j < message.universes.length; ++j)
                    object.universes[j] = $root.RandoProto.UniverseInfo.toObject(message.universes[j], options);
            }
            if (message.hasBingoBoard != null && message.hasOwnProperty("hasBingoBoard"))
                object.hasBingoBoard = message.hasBingoBoard;
            if (message.spectators && message.spectators.length) {
                object.spectators = [];
                for (let j = 0; j < message.spectators.length; ++j)
                    object.spectators[j] = $root.RandoProto.UserInfo.toObject(message.spectators[j], options);
            }
            return object;
        };

        /**
         * Converts this MultiverseInfoMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.MultiverseInfoMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MultiverseInfoMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MultiverseInfoMessage
         * @function getTypeUrl
         * @memberof RandoProto.MultiverseInfoMessage
         * @static
         * @returns {string} The default type url
         */
        MultiverseInfoMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.MultiverseInfoMessage";
        };

        return MultiverseInfoMessage;
    })();

    RandoProto.BingoSquare = (function() {

        /**
         * Properties of a BingoSquare.
         * @memberof RandoProto
         * @interface IBingoSquare
         * @property {string|null} [text] BingoSquare text
         * @property {Array.<RandoProto.IUniverseInfo>|null} [completedBy] BingoSquare completedBy
         * @property {Array.<RandoProto.IBingoGoal>|null} [goals] BingoSquare goals
         */

        /**
         * Constructs a new BingoSquare.
         * @memberof RandoProto
         * @classdesc Represents a BingoSquare.
         * @implements IBingoSquare
         * @constructor
         * @param {RandoProto.IBingoSquare=} [properties] Properties to set
         */
        function BingoSquare(properties) {
            this.completedBy = [];
            this.goals = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BingoSquare text.
         * @member {string} text
         * @memberof RandoProto.BingoSquare
         * @instance
         */
        BingoSquare.prototype.text = "";

        /**
         * BingoSquare completedBy.
         * @member {Array.<RandoProto.IUniverseInfo>} completedBy
         * @memberof RandoProto.BingoSquare
         * @instance
         */
        BingoSquare.prototype.completedBy = $util.emptyArray;

        /**
         * BingoSquare goals.
         * @member {Array.<RandoProto.IBingoGoal>} goals
         * @memberof RandoProto.BingoSquare
         * @instance
         */
        BingoSquare.prototype.goals = $util.emptyArray;

        /**
         * Creates a new BingoSquare instance using the specified properties.
         * @function create
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {RandoProto.IBingoSquare=} [properties] Properties to set
         * @returns {RandoProto.BingoSquare} BingoSquare instance
         */
        BingoSquare.create = function create(properties) {
            return new BingoSquare(properties);
        };

        /**
         * Encodes the specified BingoSquare message. Does not implicitly {@link RandoProto.BingoSquare.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {RandoProto.IBingoSquare} message BingoSquare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoSquare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.completedBy != null && message.completedBy.length)
                for (let i = 0; i < message.completedBy.length; ++i)
                    $root.RandoProto.UniverseInfo.encode(message.completedBy[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.goals != null && message.goals.length)
                for (let i = 0; i < message.goals.length; ++i)
                    $root.RandoProto.BingoGoal.encode(message.goals[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BingoSquare message, length delimited. Does not implicitly {@link RandoProto.BingoSquare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {RandoProto.IBingoSquare} message BingoSquare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoSquare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BingoSquare message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.BingoSquare} BingoSquare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoSquare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.BingoSquare();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    if (!(message.completedBy && message.completedBy.length))
                        message.completedBy = [];
                    message.completedBy.push($root.RandoProto.UniverseInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.goals && message.goals.length))
                        message.goals = [];
                    message.goals.push($root.RandoProto.BingoGoal.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BingoSquare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.BingoSquare} BingoSquare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoSquare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BingoSquare message.
         * @function verify
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BingoSquare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.completedBy != null && message.hasOwnProperty("completedBy")) {
                if (!Array.isArray(message.completedBy))
                    return "completedBy: array expected";
                for (let i = 0; i < message.completedBy.length; ++i) {
                    let error = $root.RandoProto.UniverseInfo.verify(message.completedBy[i]);
                    if (error)
                        return "completedBy." + error;
                }
            }
            if (message.goals != null && message.hasOwnProperty("goals")) {
                if (!Array.isArray(message.goals))
                    return "goals: array expected";
                for (let i = 0; i < message.goals.length; ++i) {
                    let error = $root.RandoProto.BingoGoal.verify(message.goals[i]);
                    if (error)
                        return "goals." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BingoSquare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.BingoSquare} BingoSquare
         */
        BingoSquare.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.BingoSquare)
                return object;
            let message = new $root.RandoProto.BingoSquare();
            if (object.text != null)
                message.text = String(object.text);
            if (object.completedBy) {
                if (!Array.isArray(object.completedBy))
                    throw TypeError(".RandoProto.BingoSquare.completedBy: array expected");
                message.completedBy = [];
                for (let i = 0; i < object.completedBy.length; ++i) {
                    if (typeof object.completedBy[i] !== "object")
                        throw TypeError(".RandoProto.BingoSquare.completedBy: object expected");
                    message.completedBy[i] = $root.RandoProto.UniverseInfo.fromObject(object.completedBy[i]);
                }
            }
            if (object.goals) {
                if (!Array.isArray(object.goals))
                    throw TypeError(".RandoProto.BingoSquare.goals: array expected");
                message.goals = [];
                for (let i = 0; i < object.goals.length; ++i) {
                    if (typeof object.goals[i] !== "object")
                        throw TypeError(".RandoProto.BingoSquare.goals: object expected");
                    message.goals[i] = $root.RandoProto.BingoGoal.fromObject(object.goals[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BingoSquare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.BingoSquare
         * @static
         * @param {RandoProto.BingoSquare} message BingoSquare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BingoSquare.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.completedBy = [];
                object.goals = [];
            }
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.completedBy && message.completedBy.length) {
                object.completedBy = [];
                for (let j = 0; j < message.completedBy.length; ++j)
                    object.completedBy[j] = $root.RandoProto.UniverseInfo.toObject(message.completedBy[j], options);
            }
            if (message.goals && message.goals.length) {
                object.goals = [];
                for (let j = 0; j < message.goals.length; ++j)
                    object.goals[j] = $root.RandoProto.BingoGoal.toObject(message.goals[j], options);
            }
            return object;
        };

        /**
         * Converts this BingoSquare to JSON.
         * @function toJSON
         * @memberof RandoProto.BingoSquare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BingoSquare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BingoSquare
         * @function getTypeUrl
         * @memberof RandoProto.BingoSquare
         * @static
         * @returns {string} The default type url
         */
        BingoSquare.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.BingoSquare";
        };

        return BingoSquare;
    })();

    RandoProto.RequestUpdatesMessage = (function() {

        /**
         * Properties of a RequestUpdatesMessage.
         * @memberof RandoProto
         * @interface IRequestUpdatesMessage
         * @property {string|null} [playerId] RequestUpdatesMessage playerId
         */

        /**
         * Constructs a new RequestUpdatesMessage.
         * @memberof RandoProto
         * @classdesc Represents a RequestUpdatesMessage.
         * @implements IRequestUpdatesMessage
         * @constructor
         * @param {RandoProto.IRequestUpdatesMessage=} [properties] Properties to set
         */
        function RequestUpdatesMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestUpdatesMessage playerId.
         * @member {string} playerId
         * @memberof RandoProto.RequestUpdatesMessage
         * @instance
         */
        RequestUpdatesMessage.prototype.playerId = "";

        /**
         * Creates a new RequestUpdatesMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {RandoProto.IRequestUpdatesMessage=} [properties] Properties to set
         * @returns {RandoProto.RequestUpdatesMessage} RequestUpdatesMessage instance
         */
        RequestUpdatesMessage.create = function create(properties) {
            return new RequestUpdatesMessage(properties);
        };

        /**
         * Encodes the specified RequestUpdatesMessage message. Does not implicitly {@link RandoProto.RequestUpdatesMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {RandoProto.IRequestUpdatesMessage} message RequestUpdatesMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestUpdatesMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && Object.hasOwnProperty.call(message, "playerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerId);
            return writer;
        };

        /**
         * Encodes the specified RequestUpdatesMessage message, length delimited. Does not implicitly {@link RandoProto.RequestUpdatesMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {RandoProto.IRequestUpdatesMessage} message RequestUpdatesMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestUpdatesMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestUpdatesMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.RequestUpdatesMessage} RequestUpdatesMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestUpdatesMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.RequestUpdatesMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RequestUpdatesMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.RequestUpdatesMessage} RequestUpdatesMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestUpdatesMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestUpdatesMessage message.
         * @function verify
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestUpdatesMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isString(message.playerId))
                    return "playerId: string expected";
            return null;
        };

        /**
         * Creates a RequestUpdatesMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.RequestUpdatesMessage} RequestUpdatesMessage
         */
        RequestUpdatesMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.RequestUpdatesMessage)
                return object;
            let message = new $root.RandoProto.RequestUpdatesMessage();
            if (object.playerId != null)
                message.playerId = String(object.playerId);
            return message;
        };

        /**
         * Creates a plain object from a RequestUpdatesMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @param {RandoProto.RequestUpdatesMessage} message RequestUpdatesMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestUpdatesMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.playerId = "";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = message.playerId;
            return object;
        };

        /**
         * Converts this RequestUpdatesMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.RequestUpdatesMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestUpdatesMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RequestUpdatesMessage
         * @function getTypeUrl
         * @memberof RandoProto.RequestUpdatesMessage
         * @static
         * @returns {string} The default type url
         */
        RequestUpdatesMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.RequestUpdatesMessage";
        };

        return RequestUpdatesMessage;
    })();

    RandoProto.BingoUniverseInfo = (function() {

        /**
         * Properties of a BingoUniverseInfo.
         * @memberof RandoProto
         * @interface IBingoUniverseInfo
         * @property {number|Long|null} [universeId] BingoUniverseInfo universeId
         * @property {string|null} [score] BingoUniverseInfo score
         * @property {number|null} [rank] BingoUniverseInfo rank
         * @property {number|null} [squares] BingoUniverseInfo squares
         * @property {number|null} [lines] BingoUniverseInfo lines
         */

        /**
         * Constructs a new BingoUniverseInfo.
         * @memberof RandoProto
         * @classdesc Represents a BingoUniverseInfo.
         * @implements IBingoUniverseInfo
         * @constructor
         * @param {RandoProto.IBingoUniverseInfo=} [properties] Properties to set
         */
        function BingoUniverseInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BingoUniverseInfo universeId.
         * @member {number|Long} universeId
         * @memberof RandoProto.BingoUniverseInfo
         * @instance
         */
        BingoUniverseInfo.prototype.universeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BingoUniverseInfo score.
         * @member {string} score
         * @memberof RandoProto.BingoUniverseInfo
         * @instance
         */
        BingoUniverseInfo.prototype.score = "";

        /**
         * BingoUniverseInfo rank.
         * @member {number} rank
         * @memberof RandoProto.BingoUniverseInfo
         * @instance
         */
        BingoUniverseInfo.prototype.rank = 0;

        /**
         * BingoUniverseInfo squares.
         * @member {number} squares
         * @memberof RandoProto.BingoUniverseInfo
         * @instance
         */
        BingoUniverseInfo.prototype.squares = 0;

        /**
         * BingoUniverseInfo lines.
         * @member {number} lines
         * @memberof RandoProto.BingoUniverseInfo
         * @instance
         */
        BingoUniverseInfo.prototype.lines = 0;

        /**
         * Creates a new BingoUniverseInfo instance using the specified properties.
         * @function create
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @param {RandoProto.IBingoUniverseInfo=} [properties] Properties to set
         * @returns {RandoProto.BingoUniverseInfo} BingoUniverseInfo instance
         */
        BingoUniverseInfo.create = function create(properties) {
            return new BingoUniverseInfo(properties);
        };

        /**
         * Encodes the specified BingoUniverseInfo message. Does not implicitly {@link RandoProto.BingoUniverseInfo.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @param {RandoProto.IBingoUniverseInfo} message BingoUniverseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoUniverseInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.universeId != null && Object.hasOwnProperty.call(message, "universeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.universeId);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.score);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rank);
            if (message.squares != null && Object.hasOwnProperty.call(message, "squares"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.squares);
            if (message.lines != null && Object.hasOwnProperty.call(message, "lines"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lines);
            return writer;
        };

        /**
         * Encodes the specified BingoUniverseInfo message, length delimited. Does not implicitly {@link RandoProto.BingoUniverseInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @param {RandoProto.IBingoUniverseInfo} message BingoUniverseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoUniverseInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BingoUniverseInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.BingoUniverseInfo} BingoUniverseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoUniverseInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.BingoUniverseInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.universeId = reader.int64();
                    break;
                case 3:
                    message.score = reader.string();
                    break;
                case 4:
                    message.rank = reader.int32();
                    break;
                case 5:
                    message.squares = reader.int32();
                    break;
                case 6:
                    message.lines = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BingoUniverseInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.BingoUniverseInfo} BingoUniverseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoUniverseInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BingoUniverseInfo message.
         * @function verify
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BingoUniverseInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.universeId != null && message.hasOwnProperty("universeId"))
                if (!$util.isInteger(message.universeId) && !(message.universeId && $util.isInteger(message.universeId.low) && $util.isInteger(message.universeId.high)))
                    return "universeId: integer|Long expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isString(message.score))
                    return "score: string expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.squares != null && message.hasOwnProperty("squares"))
                if (!$util.isInteger(message.squares))
                    return "squares: integer expected";
            if (message.lines != null && message.hasOwnProperty("lines"))
                if (!$util.isInteger(message.lines))
                    return "lines: integer expected";
            return null;
        };

        /**
         * Creates a BingoUniverseInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.BingoUniverseInfo} BingoUniverseInfo
         */
        BingoUniverseInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.BingoUniverseInfo)
                return object;
            let message = new $root.RandoProto.BingoUniverseInfo();
            if (object.universeId != null)
                if ($util.Long)
                    (message.universeId = $util.Long.fromValue(object.universeId)).unsigned = false;
                else if (typeof object.universeId === "string")
                    message.universeId = parseInt(object.universeId, 10);
                else if (typeof object.universeId === "number")
                    message.universeId = object.universeId;
                else if (typeof object.universeId === "object")
                    message.universeId = new $util.LongBits(object.universeId.low >>> 0, object.universeId.high >>> 0).toNumber();
            if (object.score != null)
                message.score = String(object.score);
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.squares != null)
                message.squares = object.squares | 0;
            if (object.lines != null)
                message.lines = object.lines | 0;
            return message;
        };

        /**
         * Creates a plain object from a BingoUniverseInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @param {RandoProto.BingoUniverseInfo} message BingoUniverseInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BingoUniverseInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.universeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.universeId = options.longs === String ? "0" : 0;
                object.score = "";
                object.rank = 0;
                object.squares = 0;
                object.lines = 0;
            }
            if (message.universeId != null && message.hasOwnProperty("universeId"))
                if (typeof message.universeId === "number")
                    object.universeId = options.longs === String ? String(message.universeId) : message.universeId;
                else
                    object.universeId = options.longs === String ? $util.Long.prototype.toString.call(message.universeId) : options.longs === Number ? new $util.LongBits(message.universeId.low >>> 0, message.universeId.high >>> 0).toNumber() : message.universeId;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.squares != null && message.hasOwnProperty("squares"))
                object.squares = message.squares;
            if (message.lines != null && message.hasOwnProperty("lines"))
                object.lines = message.lines;
            return object;
        };

        /**
         * Converts this BingoUniverseInfo to JSON.
         * @function toJSON
         * @memberof RandoProto.BingoUniverseInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BingoUniverseInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BingoUniverseInfo
         * @function getTypeUrl
         * @memberof RandoProto.BingoUniverseInfo
         * @static
         * @returns {string} The default type url
         */
        BingoUniverseInfo.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.BingoUniverseInfo";
        };

        return BingoUniverseInfo;
    })();

    RandoProto.SyncBingoUniversesMessage = (function() {

        /**
         * Properties of a SyncBingoUniversesMessage.
         * @memberof RandoProto
         * @interface ISyncBingoUniversesMessage
         * @property {Array.<RandoProto.IBingoUniverseInfo>|null} [bingoUniverses] SyncBingoUniversesMessage bingoUniverses
         */

        /**
         * Constructs a new SyncBingoUniversesMessage.
         * @memberof RandoProto
         * @classdesc Represents a SyncBingoUniversesMessage.
         * @implements ISyncBingoUniversesMessage
         * @constructor
         * @param {RandoProto.ISyncBingoUniversesMessage=} [properties] Properties to set
         */
        function SyncBingoUniversesMessage(properties) {
            this.bingoUniverses = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncBingoUniversesMessage bingoUniverses.
         * @member {Array.<RandoProto.IBingoUniverseInfo>} bingoUniverses
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @instance
         */
        SyncBingoUniversesMessage.prototype.bingoUniverses = $util.emptyArray;

        /**
         * Creates a new SyncBingoUniversesMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @param {RandoProto.ISyncBingoUniversesMessage=} [properties] Properties to set
         * @returns {RandoProto.SyncBingoUniversesMessage} SyncBingoUniversesMessage instance
         */
        SyncBingoUniversesMessage.create = function create(properties) {
            return new SyncBingoUniversesMessage(properties);
        };

        /**
         * Encodes the specified SyncBingoUniversesMessage message. Does not implicitly {@link RandoProto.SyncBingoUniversesMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @param {RandoProto.ISyncBingoUniversesMessage} message SyncBingoUniversesMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncBingoUniversesMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bingoUniverses != null && message.bingoUniverses.length)
                for (let i = 0; i < message.bingoUniverses.length; ++i)
                    $root.RandoProto.BingoUniverseInfo.encode(message.bingoUniverses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncBingoUniversesMessage message, length delimited. Does not implicitly {@link RandoProto.SyncBingoUniversesMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @param {RandoProto.ISyncBingoUniversesMessage} message SyncBingoUniversesMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncBingoUniversesMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncBingoUniversesMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.SyncBingoUniversesMessage} SyncBingoUniversesMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncBingoUniversesMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.SyncBingoUniversesMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.bingoUniverses && message.bingoUniverses.length))
                        message.bingoUniverses = [];
                    message.bingoUniverses.push($root.RandoProto.BingoUniverseInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncBingoUniversesMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.SyncBingoUniversesMessage} SyncBingoUniversesMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncBingoUniversesMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncBingoUniversesMessage message.
         * @function verify
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncBingoUniversesMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bingoUniverses != null && message.hasOwnProperty("bingoUniverses")) {
                if (!Array.isArray(message.bingoUniverses))
                    return "bingoUniverses: array expected";
                for (let i = 0; i < message.bingoUniverses.length; ++i) {
                    let error = $root.RandoProto.BingoUniverseInfo.verify(message.bingoUniverses[i]);
                    if (error)
                        return "bingoUniverses." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SyncBingoUniversesMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.SyncBingoUniversesMessage} SyncBingoUniversesMessage
         */
        SyncBingoUniversesMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.SyncBingoUniversesMessage)
                return object;
            let message = new $root.RandoProto.SyncBingoUniversesMessage();
            if (object.bingoUniverses) {
                if (!Array.isArray(object.bingoUniverses))
                    throw TypeError(".RandoProto.SyncBingoUniversesMessage.bingoUniverses: array expected");
                message.bingoUniverses = [];
                for (let i = 0; i < object.bingoUniverses.length; ++i) {
                    if (typeof object.bingoUniverses[i] !== "object")
                        throw TypeError(".RandoProto.SyncBingoUniversesMessage.bingoUniverses: object expected");
                    message.bingoUniverses[i] = $root.RandoProto.BingoUniverseInfo.fromObject(object.bingoUniverses[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncBingoUniversesMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @param {RandoProto.SyncBingoUniversesMessage} message SyncBingoUniversesMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncBingoUniversesMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.bingoUniverses = [];
            if (message.bingoUniverses && message.bingoUniverses.length) {
                object.bingoUniverses = [];
                for (let j = 0; j < message.bingoUniverses.length; ++j)
                    object.bingoUniverses[j] = $root.RandoProto.BingoUniverseInfo.toObject(message.bingoUniverses[j], options);
            }
            return object;
        };

        /**
         * Converts this SyncBingoUniversesMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncBingoUniversesMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncBingoUniversesMessage
         * @function getTypeUrl
         * @memberof RandoProto.SyncBingoUniversesMessage
         * @static
         * @returns {string} The default type url
         */
        SyncBingoUniversesMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.SyncBingoUniversesMessage";
        };

        return SyncBingoUniversesMessage;
    })();

    RandoProto.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof RandoProto
         * @interface IPosition
         * @property {number|null} [x] Position x
         * @property {number|null} [y] Position y
         */

        /**
         * Constructs a new Position.
         * @memberof RandoProto
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {RandoProto.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position x.
         * @member {number} x
         * @memberof RandoProto.Position
         * @instance
         */
        Position.prototype.x = 0;

        /**
         * Position y.
         * @member {number} y
         * @memberof RandoProto.Position
         * @instance
         */
        Position.prototype.y = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof RandoProto.Position
         * @static
         * @param {RandoProto.IPosition=} [properties] Properties to set
         * @returns {RandoProto.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link RandoProto.Position.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.Position
         * @static
         * @param {RandoProto.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link RandoProto.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.Position
         * @static
         * @param {RandoProto.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.Position();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof RandoProto.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.Position)
                return object;
            let message = new $root.RandoProto.Position();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.Position
         * @static
         * @param {RandoProto.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof RandoProto.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Position
         * @function getTypeUrl
         * @memberof RandoProto.Position
         * @static
         * @returns {string} The default type url
         */
        Position.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.Position";
        };

        return Position;
    })();

    RandoProto.PositionedBingoSquare = (function() {

        /**
         * Properties of a PositionedBingoSquare.
         * @memberof RandoProto
         * @interface IPositionedBingoSquare
         * @property {RandoProto.IPosition|null} [position] PositionedBingoSquare position
         * @property {RandoProto.IBingoSquare|null} [square] PositionedBingoSquare square
         */

        /**
         * Constructs a new PositionedBingoSquare.
         * @memberof RandoProto
         * @classdesc Represents a PositionedBingoSquare.
         * @implements IPositionedBingoSquare
         * @constructor
         * @param {RandoProto.IPositionedBingoSquare=} [properties] Properties to set
         */
        function PositionedBingoSquare(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PositionedBingoSquare position.
         * @member {RandoProto.IPosition|null|undefined} position
         * @memberof RandoProto.PositionedBingoSquare
         * @instance
         */
        PositionedBingoSquare.prototype.position = null;

        /**
         * PositionedBingoSquare square.
         * @member {RandoProto.IBingoSquare|null|undefined} square
         * @memberof RandoProto.PositionedBingoSquare
         * @instance
         */
        PositionedBingoSquare.prototype.square = null;

        /**
         * Creates a new PositionedBingoSquare instance using the specified properties.
         * @function create
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {RandoProto.IPositionedBingoSquare=} [properties] Properties to set
         * @returns {RandoProto.PositionedBingoSquare} PositionedBingoSquare instance
         */
        PositionedBingoSquare.create = function create(properties) {
            return new PositionedBingoSquare(properties);
        };

        /**
         * Encodes the specified PositionedBingoSquare message. Does not implicitly {@link RandoProto.PositionedBingoSquare.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {RandoProto.IPositionedBingoSquare} message PositionedBingoSquare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionedBingoSquare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.RandoProto.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.square != null && Object.hasOwnProperty.call(message, "square"))
                $root.RandoProto.BingoSquare.encode(message.square, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PositionedBingoSquare message, length delimited. Does not implicitly {@link RandoProto.PositionedBingoSquare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {RandoProto.IPositionedBingoSquare} message PositionedBingoSquare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionedBingoSquare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PositionedBingoSquare message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.PositionedBingoSquare} PositionedBingoSquare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionedBingoSquare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.PositionedBingoSquare();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = $root.RandoProto.Position.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.square = $root.RandoProto.BingoSquare.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PositionedBingoSquare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.PositionedBingoSquare} PositionedBingoSquare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionedBingoSquare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PositionedBingoSquare message.
         * @function verify
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PositionedBingoSquare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                let error = $root.RandoProto.Position.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.square != null && message.hasOwnProperty("square")) {
                let error = $root.RandoProto.BingoSquare.verify(message.square);
                if (error)
                    return "square." + error;
            }
            return null;
        };

        /**
         * Creates a PositionedBingoSquare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.PositionedBingoSquare} PositionedBingoSquare
         */
        PositionedBingoSquare.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.PositionedBingoSquare)
                return object;
            let message = new $root.RandoProto.PositionedBingoSquare();
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".RandoProto.PositionedBingoSquare.position: object expected");
                message.position = $root.RandoProto.Position.fromObject(object.position);
            }
            if (object.square != null) {
                if (typeof object.square !== "object")
                    throw TypeError(".RandoProto.PositionedBingoSquare.square: object expected");
                message.square = $root.RandoProto.BingoSquare.fromObject(object.square);
            }
            return message;
        };

        /**
         * Creates a plain object from a PositionedBingoSquare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @param {RandoProto.PositionedBingoSquare} message PositionedBingoSquare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PositionedBingoSquare.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.position = null;
                object.square = null;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.RandoProto.Position.toObject(message.position, options);
            if (message.square != null && message.hasOwnProperty("square"))
                object.square = $root.RandoProto.BingoSquare.toObject(message.square, options);
            return object;
        };

        /**
         * Converts this PositionedBingoSquare to JSON.
         * @function toJSON
         * @memberof RandoProto.PositionedBingoSquare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PositionedBingoSquare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PositionedBingoSquare
         * @function getTypeUrl
         * @memberof RandoProto.PositionedBingoSquare
         * @static
         * @returns {string} The default type url
         */
        PositionedBingoSquare.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.PositionedBingoSquare";
        };

        return PositionedBingoSquare;
    })();

    RandoProto.BingoBoard = (function() {

        /**
         * Properties of a BingoBoard.
         * @memberof RandoProto
         * @interface IBingoBoard
         * @property {Array.<RandoProto.IPositionedBingoSquare>|null} [squares] BingoBoard squares
         * @property {number|null} [size] BingoBoard size
         */

        /**
         * Constructs a new BingoBoard.
         * @memberof RandoProto
         * @classdesc Represents a BingoBoard.
         * @implements IBingoBoard
         * @constructor
         * @param {RandoProto.IBingoBoard=} [properties] Properties to set
         */
        function BingoBoard(properties) {
            this.squares = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BingoBoard squares.
         * @member {Array.<RandoProto.IPositionedBingoSquare>} squares
         * @memberof RandoProto.BingoBoard
         * @instance
         */
        BingoBoard.prototype.squares = $util.emptyArray;

        /**
         * BingoBoard size.
         * @member {number} size
         * @memberof RandoProto.BingoBoard
         * @instance
         */
        BingoBoard.prototype.size = 0;

        /**
         * Creates a new BingoBoard instance using the specified properties.
         * @function create
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {RandoProto.IBingoBoard=} [properties] Properties to set
         * @returns {RandoProto.BingoBoard} BingoBoard instance
         */
        BingoBoard.create = function create(properties) {
            return new BingoBoard(properties);
        };

        /**
         * Encodes the specified BingoBoard message. Does not implicitly {@link RandoProto.BingoBoard.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {RandoProto.IBingoBoard} message BingoBoard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoBoard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.squares != null && message.squares.length)
                for (let i = 0; i < message.squares.length; ++i)
                    $root.RandoProto.PositionedBingoSquare.encode(message.squares[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.size);
            return writer;
        };

        /**
         * Encodes the specified BingoBoard message, length delimited. Does not implicitly {@link RandoProto.BingoBoard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {RandoProto.IBingoBoard} message BingoBoard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BingoBoard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BingoBoard message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.BingoBoard} BingoBoard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoBoard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.BingoBoard();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.squares && message.squares.length))
                        message.squares = [];
                    message.squares.push($root.RandoProto.PositionedBingoSquare.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.size = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BingoBoard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.BingoBoard} BingoBoard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BingoBoard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BingoBoard message.
         * @function verify
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BingoBoard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.squares != null && message.hasOwnProperty("squares")) {
                if (!Array.isArray(message.squares))
                    return "squares: array expected";
                for (let i = 0; i < message.squares.length; ++i) {
                    let error = $root.RandoProto.PositionedBingoSquare.verify(message.squares[i]);
                    if (error)
                        return "squares." + error;
                }
            }
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            return null;
        };

        /**
         * Creates a BingoBoard message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.BingoBoard} BingoBoard
         */
        BingoBoard.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.BingoBoard)
                return object;
            let message = new $root.RandoProto.BingoBoard();
            if (object.squares) {
                if (!Array.isArray(object.squares))
                    throw TypeError(".RandoProto.BingoBoard.squares: array expected");
                message.squares = [];
                for (let i = 0; i < object.squares.length; ++i) {
                    if (typeof object.squares[i] !== "object")
                        throw TypeError(".RandoProto.BingoBoard.squares: object expected");
                    message.squares[i] = $root.RandoProto.PositionedBingoSquare.fromObject(object.squares[i]);
                }
            }
            if (object.size != null)
                message.size = object.size | 0;
            return message;
        };

        /**
         * Creates a plain object from a BingoBoard message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.BingoBoard
         * @static
         * @param {RandoProto.BingoBoard} message BingoBoard
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BingoBoard.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.squares = [];
            if (options.defaults)
                object.size = 0;
            if (message.squares && message.squares.length) {
                object.squares = [];
                for (let j = 0; j < message.squares.length; ++j)
                    object.squares[j] = $root.RandoProto.PositionedBingoSquare.toObject(message.squares[j], options);
            }
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            return object;
        };

        /**
         * Converts this BingoBoard to JSON.
         * @function toJSON
         * @memberof RandoProto.BingoBoard
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BingoBoard.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BingoBoard
         * @function getTypeUrl
         * @memberof RandoProto.BingoBoard
         * @static
         * @returns {string} The default type url
         */
        BingoBoard.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.BingoBoard";
        };

        return BingoBoard;
    })();

    RandoProto.SyncBoardMessage = (function() {

        /**
         * Properties of a SyncBoardMessage.
         * @memberof RandoProto
         * @interface ISyncBoardMessage
         * @property {RandoProto.IBingoBoard|null} [board] SyncBoardMessage board
         * @property {boolean|null} [replace] SyncBoardMessage replace
         */

        /**
         * Constructs a new SyncBoardMessage.
         * @memberof RandoProto
         * @classdesc Represents a SyncBoardMessage.
         * @implements ISyncBoardMessage
         * @constructor
         * @param {RandoProto.ISyncBoardMessage=} [properties] Properties to set
         */
        function SyncBoardMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncBoardMessage board.
         * @member {RandoProto.IBingoBoard|null|undefined} board
         * @memberof RandoProto.SyncBoardMessage
         * @instance
         */
        SyncBoardMessage.prototype.board = null;

        /**
         * SyncBoardMessage replace.
         * @member {boolean} replace
         * @memberof RandoProto.SyncBoardMessage
         * @instance
         */
        SyncBoardMessage.prototype.replace = false;

        /**
         * Creates a new SyncBoardMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {RandoProto.ISyncBoardMessage=} [properties] Properties to set
         * @returns {RandoProto.SyncBoardMessage} SyncBoardMessage instance
         */
        SyncBoardMessage.create = function create(properties) {
            return new SyncBoardMessage(properties);
        };

        /**
         * Encodes the specified SyncBoardMessage message. Does not implicitly {@link RandoProto.SyncBoardMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {RandoProto.ISyncBoardMessage} message SyncBoardMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncBoardMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.board != null && Object.hasOwnProperty.call(message, "board"))
                $root.RandoProto.BingoBoard.encode(message.board, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.replace != null && Object.hasOwnProperty.call(message, "replace"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.replace);
            return writer;
        };

        /**
         * Encodes the specified SyncBoardMessage message, length delimited. Does not implicitly {@link RandoProto.SyncBoardMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {RandoProto.ISyncBoardMessage} message SyncBoardMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncBoardMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncBoardMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.SyncBoardMessage} SyncBoardMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncBoardMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.SyncBoardMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.board = $root.RandoProto.BingoBoard.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.replace = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncBoardMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.SyncBoardMessage} SyncBoardMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncBoardMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncBoardMessage message.
         * @function verify
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncBoardMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.board != null && message.hasOwnProperty("board")) {
                let error = $root.RandoProto.BingoBoard.verify(message.board);
                if (error)
                    return "board." + error;
            }
            if (message.replace != null && message.hasOwnProperty("replace"))
                if (typeof message.replace !== "boolean")
                    return "replace: boolean expected";
            return null;
        };

        /**
         * Creates a SyncBoardMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.SyncBoardMessage} SyncBoardMessage
         */
        SyncBoardMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.SyncBoardMessage)
                return object;
            let message = new $root.RandoProto.SyncBoardMessage();
            if (object.board != null) {
                if (typeof object.board !== "object")
                    throw TypeError(".RandoProto.SyncBoardMessage.board: object expected");
                message.board = $root.RandoProto.BingoBoard.fromObject(object.board);
            }
            if (object.replace != null)
                message.replace = Boolean(object.replace);
            return message;
        };

        /**
         * Creates a plain object from a SyncBoardMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @param {RandoProto.SyncBoardMessage} message SyncBoardMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncBoardMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.board = null;
                object.replace = false;
            }
            if (message.board != null && message.hasOwnProperty("board"))
                object.board = $root.RandoProto.BingoBoard.toObject(message.board, options);
            if (message.replace != null && message.hasOwnProperty("replace"))
                object.replace = message.replace;
            return object;
        };

        /**
         * Converts this SyncBoardMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.SyncBoardMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncBoardMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncBoardMessage
         * @function getTypeUrl
         * @memberof RandoProto.SyncBoardMessage
         * @static
         * @returns {string} The default type url
         */
        SyncBoardMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.SyncBoardMessage";
        };

        return SyncBoardMessage;
    })();

    RandoProto.AuthenticateMessage = (function() {

        /**
         * Properties of an AuthenticateMessage.
         * @memberof RandoProto
         * @interface IAuthenticateMessage
         * @property {string|null} [jwt] AuthenticateMessage jwt
         */

        /**
         * Constructs a new AuthenticateMessage.
         * @memberof RandoProto
         * @classdesc Represents an AuthenticateMessage.
         * @implements IAuthenticateMessage
         * @constructor
         * @param {RandoProto.IAuthenticateMessage=} [properties] Properties to set
         */
        function AuthenticateMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthenticateMessage jwt.
         * @member {string} jwt
         * @memberof RandoProto.AuthenticateMessage
         * @instance
         */
        AuthenticateMessage.prototype.jwt = "";

        /**
         * Creates a new AuthenticateMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @param {RandoProto.IAuthenticateMessage=} [properties] Properties to set
         * @returns {RandoProto.AuthenticateMessage} AuthenticateMessage instance
         */
        AuthenticateMessage.create = function create(properties) {
            return new AuthenticateMessage(properties);
        };

        /**
         * Encodes the specified AuthenticateMessage message. Does not implicitly {@link RandoProto.AuthenticateMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @param {RandoProto.IAuthenticateMessage} message AuthenticateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticateMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jwt != null && Object.hasOwnProperty.call(message, "jwt"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.jwt);
            return writer;
        };

        /**
         * Encodes the specified AuthenticateMessage message, length delimited. Does not implicitly {@link RandoProto.AuthenticateMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @param {RandoProto.IAuthenticateMessage} message AuthenticateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticateMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthenticateMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.AuthenticateMessage} AuthenticateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticateMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.AuthenticateMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.jwt = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthenticateMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.AuthenticateMessage} AuthenticateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticateMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthenticateMessage message.
         * @function verify
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthenticateMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                if (!$util.isString(message.jwt))
                    return "jwt: string expected";
            return null;
        };

        /**
         * Creates an AuthenticateMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.AuthenticateMessage} AuthenticateMessage
         */
        AuthenticateMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.AuthenticateMessage)
                return object;
            let message = new $root.RandoProto.AuthenticateMessage();
            if (object.jwt != null)
                message.jwt = String(object.jwt);
            return message;
        };

        /**
         * Creates a plain object from an AuthenticateMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @param {RandoProto.AuthenticateMessage} message AuthenticateMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthenticateMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.jwt = "";
            if (message.jwt != null && message.hasOwnProperty("jwt"))
                object.jwt = message.jwt;
            return object;
        };

        /**
         * Converts this AuthenticateMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.AuthenticateMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthenticateMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AuthenticateMessage
         * @function getTypeUrl
         * @memberof RandoProto.AuthenticateMessage
         * @static
         * @returns {string} The default type url
         */
        AuthenticateMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.AuthenticateMessage";
        };

        return AuthenticateMessage;
    })();

    RandoProto.AuthenticatedMessage = (function() {

        /**
         * Properties of an AuthenticatedMessage.
         * @memberof RandoProto
         * @interface IAuthenticatedMessage
         * @property {RandoProto.IUserInfo|null} [user] AuthenticatedMessage user
         * @property {number|null} [udpId] AuthenticatedMessage udpId
         * @property {Uint8Array|null} [udpKey] AuthenticatedMessage udpKey
         */

        /**
         * Constructs a new AuthenticatedMessage.
         * @memberof RandoProto
         * @classdesc Represents an AuthenticatedMessage.
         * @implements IAuthenticatedMessage
         * @constructor
         * @param {RandoProto.IAuthenticatedMessage=} [properties] Properties to set
         */
        function AuthenticatedMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthenticatedMessage user.
         * @member {RandoProto.IUserInfo|null|undefined} user
         * @memberof RandoProto.AuthenticatedMessage
         * @instance
         */
        AuthenticatedMessage.prototype.user = null;

        /**
         * AuthenticatedMessage udpId.
         * @member {number} udpId
         * @memberof RandoProto.AuthenticatedMessage
         * @instance
         */
        AuthenticatedMessage.prototype.udpId = 0;

        /**
         * AuthenticatedMessage udpKey.
         * @member {Uint8Array} udpKey
         * @memberof RandoProto.AuthenticatedMessage
         * @instance
         */
        AuthenticatedMessage.prototype.udpKey = $util.newBuffer([]);

        /**
         * Creates a new AuthenticatedMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @param {RandoProto.IAuthenticatedMessage=} [properties] Properties to set
         * @returns {RandoProto.AuthenticatedMessage} AuthenticatedMessage instance
         */
        AuthenticatedMessage.create = function create(properties) {
            return new AuthenticatedMessage(properties);
        };

        /**
         * Encodes the specified AuthenticatedMessage message. Does not implicitly {@link RandoProto.AuthenticatedMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @param {RandoProto.IAuthenticatedMessage} message AuthenticatedMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticatedMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                $root.RandoProto.UserInfo.encode(message.user, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.udpId != null && Object.hasOwnProperty.call(message, "udpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.udpId);
            if (message.udpKey != null && Object.hasOwnProperty.call(message, "udpKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.udpKey);
            return writer;
        };

        /**
         * Encodes the specified AuthenticatedMessage message, length delimited. Does not implicitly {@link RandoProto.AuthenticatedMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @param {RandoProto.IAuthenticatedMessage} message AuthenticatedMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticatedMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthenticatedMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.AuthenticatedMessage} AuthenticatedMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticatedMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.AuthenticatedMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.user = $root.RandoProto.UserInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.udpId = reader.int32();
                    break;
                case 3:
                    message.udpKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthenticatedMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.AuthenticatedMessage} AuthenticatedMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticatedMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthenticatedMessage message.
         * @function verify
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthenticatedMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.user != null && message.hasOwnProperty("user")) {
                let error = $root.RandoProto.UserInfo.verify(message.user);
                if (error)
                    return "user." + error;
            }
            if (message.udpId != null && message.hasOwnProperty("udpId"))
                if (!$util.isInteger(message.udpId))
                    return "udpId: integer expected";
            if (message.udpKey != null && message.hasOwnProperty("udpKey"))
                if (!(message.udpKey && typeof message.udpKey.length === "number" || $util.isString(message.udpKey)))
                    return "udpKey: buffer expected";
            return null;
        };

        /**
         * Creates an AuthenticatedMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.AuthenticatedMessage} AuthenticatedMessage
         */
        AuthenticatedMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.AuthenticatedMessage)
                return object;
            let message = new $root.RandoProto.AuthenticatedMessage();
            if (object.user != null) {
                if (typeof object.user !== "object")
                    throw TypeError(".RandoProto.AuthenticatedMessage.user: object expected");
                message.user = $root.RandoProto.UserInfo.fromObject(object.user);
            }
            if (object.udpId != null)
                message.udpId = object.udpId | 0;
            if (object.udpKey != null)
                if (typeof object.udpKey === "string")
                    $util.base64.decode(object.udpKey, message.udpKey = $util.newBuffer($util.base64.length(object.udpKey)), 0);
                else if (object.udpKey.length)
                    message.udpKey = object.udpKey;
            return message;
        };

        /**
         * Creates a plain object from an AuthenticatedMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @param {RandoProto.AuthenticatedMessage} message AuthenticatedMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthenticatedMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.user = null;
                object.udpId = 0;
                if (options.bytes === String)
                    object.udpKey = "";
                else {
                    object.udpKey = [];
                    if (options.bytes !== Array)
                        object.udpKey = $util.newBuffer(object.udpKey);
                }
            }
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = $root.RandoProto.UserInfo.toObject(message.user, options);
            if (message.udpId != null && message.hasOwnProperty("udpId"))
                object.udpId = message.udpId;
            if (message.udpKey != null && message.hasOwnProperty("udpKey"))
                object.udpKey = options.bytes === String ? $util.base64.encode(message.udpKey, 0, message.udpKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.udpKey) : message.udpKey;
            return object;
        };

        /**
         * Converts this AuthenticatedMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.AuthenticatedMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthenticatedMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AuthenticatedMessage
         * @function getTypeUrl
         * @memberof RandoProto.AuthenticatedMessage
         * @static
         * @returns {string} The default type url
         */
        AuthenticatedMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.AuthenticatedMessage";
        };

        return AuthenticatedMessage;
    })();

    RandoProto.PlayerPositionMessage = (function() {

        /**
         * Properties of a PlayerPositionMessage.
         * @memberof RandoProto
         * @interface IPlayerPositionMessage
         * @property {number|null} [x] PlayerPositionMessage x
         * @property {number|null} [y] PlayerPositionMessage y
         */

        /**
         * Constructs a new PlayerPositionMessage.
         * @memberof RandoProto
         * @classdesc Represents a PlayerPositionMessage.
         * @implements IPlayerPositionMessage
         * @constructor
         * @param {RandoProto.IPlayerPositionMessage=} [properties] Properties to set
         */
        function PlayerPositionMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerPositionMessage x.
         * @member {number} x
         * @memberof RandoProto.PlayerPositionMessage
         * @instance
         */
        PlayerPositionMessage.prototype.x = 0;

        /**
         * PlayerPositionMessage y.
         * @member {number} y
         * @memberof RandoProto.PlayerPositionMessage
         * @instance
         */
        PlayerPositionMessage.prototype.y = 0;

        /**
         * Creates a new PlayerPositionMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @param {RandoProto.IPlayerPositionMessage=} [properties] Properties to set
         * @returns {RandoProto.PlayerPositionMessage} PlayerPositionMessage instance
         */
        PlayerPositionMessage.create = function create(properties) {
            return new PlayerPositionMessage(properties);
        };

        /**
         * Encodes the specified PlayerPositionMessage message. Does not implicitly {@link RandoProto.PlayerPositionMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @param {RandoProto.IPlayerPositionMessage} message PlayerPositionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerPositionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };

        /**
         * Encodes the specified PlayerPositionMessage message, length delimited. Does not implicitly {@link RandoProto.PlayerPositionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @param {RandoProto.IPlayerPositionMessage} message PlayerPositionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerPositionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerPositionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.PlayerPositionMessage} PlayerPositionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerPositionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.PlayerPositionMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerPositionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.PlayerPositionMessage} PlayerPositionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerPositionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerPositionMessage message.
         * @function verify
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerPositionMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates a PlayerPositionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.PlayerPositionMessage} PlayerPositionMessage
         */
        PlayerPositionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.PlayerPositionMessage)
                return object;
            let message = new $root.RandoProto.PlayerPositionMessage();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a PlayerPositionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @param {RandoProto.PlayerPositionMessage} message PlayerPositionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerPositionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this PlayerPositionMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.PlayerPositionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerPositionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PlayerPositionMessage
         * @function getTypeUrl
         * @memberof RandoProto.PlayerPositionMessage
         * @static
         * @returns {string} The default type url
         */
        PlayerPositionMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.PlayerPositionMessage";
        };

        return PlayerPositionMessage;
    })();

    RandoProto.UpdatePlayerPositionMessage = (function() {

        /**
         * Properties of an UpdatePlayerPositionMessage.
         * @memberof RandoProto
         * @interface IUpdatePlayerPositionMessage
         * @property {string|null} [playerId] UpdatePlayerPositionMessage playerId
         * @property {number|null} [x] UpdatePlayerPositionMessage x
         * @property {number|null} [y] UpdatePlayerPositionMessage y
         */

        /**
         * Constructs a new UpdatePlayerPositionMessage.
         * @memberof RandoProto
         * @classdesc Represents an UpdatePlayerPositionMessage.
         * @implements IUpdatePlayerPositionMessage
         * @constructor
         * @param {RandoProto.IUpdatePlayerPositionMessage=} [properties] Properties to set
         */
        function UpdatePlayerPositionMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdatePlayerPositionMessage playerId.
         * @member {string} playerId
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @instance
         */
        UpdatePlayerPositionMessage.prototype.playerId = "";

        /**
         * UpdatePlayerPositionMessage x.
         * @member {number} x
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @instance
         */
        UpdatePlayerPositionMessage.prototype.x = 0;

        /**
         * UpdatePlayerPositionMessage y.
         * @member {number} y
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @instance
         */
        UpdatePlayerPositionMessage.prototype.y = 0;

        /**
         * Creates a new UpdatePlayerPositionMessage instance using the specified properties.
         * @function create
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @param {RandoProto.IUpdatePlayerPositionMessage=} [properties] Properties to set
         * @returns {RandoProto.UpdatePlayerPositionMessage} UpdatePlayerPositionMessage instance
         */
        UpdatePlayerPositionMessage.create = function create(properties) {
            return new UpdatePlayerPositionMessage(properties);
        };

        /**
         * Encodes the specified UpdatePlayerPositionMessage message. Does not implicitly {@link RandoProto.UpdatePlayerPositionMessage.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @param {RandoProto.IUpdatePlayerPositionMessage} message UpdatePlayerPositionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePlayerPositionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && Object.hasOwnProperty.call(message, "playerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerId);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.y);
            return writer;
        };

        /**
         * Encodes the specified UpdatePlayerPositionMessage message, length delimited. Does not implicitly {@link RandoProto.UpdatePlayerPositionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @param {RandoProto.IUpdatePlayerPositionMessage} message UpdatePlayerPositionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePlayerPositionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdatePlayerPositionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.UpdatePlayerPositionMessage} UpdatePlayerPositionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePlayerPositionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.UpdatePlayerPositionMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerId = reader.string();
                    break;
                case 2:
                    message.x = reader.float();
                    break;
                case 3:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdatePlayerPositionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.UpdatePlayerPositionMessage} UpdatePlayerPositionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePlayerPositionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdatePlayerPositionMessage message.
         * @function verify
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdatePlayerPositionMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isString(message.playerId))
                    return "playerId: string expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates an UpdatePlayerPositionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.UpdatePlayerPositionMessage} UpdatePlayerPositionMessage
         */
        UpdatePlayerPositionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.UpdatePlayerPositionMessage)
                return object;
            let message = new $root.RandoProto.UpdatePlayerPositionMessage();
            if (object.playerId != null)
                message.playerId = String(object.playerId);
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from an UpdatePlayerPositionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @param {RandoProto.UpdatePlayerPositionMessage} message UpdatePlayerPositionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdatePlayerPositionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.playerId = "";
                object.x = 0;
                object.y = 0;
            }
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = message.playerId;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this UpdatePlayerPositionMessage to JSON.
         * @function toJSON
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdatePlayerPositionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UpdatePlayerPositionMessage
         * @function getTypeUrl
         * @memberof RandoProto.UpdatePlayerPositionMessage
         * @static
         * @returns {string} The default type url
         */
        UpdatePlayerPositionMessage.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.UpdatePlayerPositionMessage";
        };

        return UpdatePlayerPositionMessage;
    })();

    RandoProto.UdpPacket = (function() {

        /**
         * Properties of an UdpPacket.
         * @memberof RandoProto
         * @interface IUdpPacket
         * @property {number|null} [udpId] UdpPacket udpId
         * @property {Uint8Array|null} [encryptedPacket] UdpPacket encryptedPacket
         */

        /**
         * Constructs a new UdpPacket.
         * @memberof RandoProto
         * @classdesc Represents an UdpPacket.
         * @implements IUdpPacket
         * @constructor
         * @param {RandoProto.IUdpPacket=} [properties] Properties to set
         */
        function UdpPacket(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UdpPacket udpId.
         * @member {number} udpId
         * @memberof RandoProto.UdpPacket
         * @instance
         */
        UdpPacket.prototype.udpId = 0;

        /**
         * UdpPacket encryptedPacket.
         * @member {Uint8Array} encryptedPacket
         * @memberof RandoProto.UdpPacket
         * @instance
         */
        UdpPacket.prototype.encryptedPacket = $util.newBuffer([]);

        /**
         * Creates a new UdpPacket instance using the specified properties.
         * @function create
         * @memberof RandoProto.UdpPacket
         * @static
         * @param {RandoProto.IUdpPacket=} [properties] Properties to set
         * @returns {RandoProto.UdpPacket} UdpPacket instance
         */
        UdpPacket.create = function create(properties) {
            return new UdpPacket(properties);
        };

        /**
         * Encodes the specified UdpPacket message. Does not implicitly {@link RandoProto.UdpPacket.verify|verify} messages.
         * @function encode
         * @memberof RandoProto.UdpPacket
         * @static
         * @param {RandoProto.IUdpPacket} message UdpPacket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UdpPacket.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.udpId != null && Object.hasOwnProperty.call(message, "udpId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.udpId);
            if (message.encryptedPacket != null && Object.hasOwnProperty.call(message, "encryptedPacket"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedPacket);
            return writer;
        };

        /**
         * Encodes the specified UdpPacket message, length delimited. Does not implicitly {@link RandoProto.UdpPacket.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RandoProto.UdpPacket
         * @static
         * @param {RandoProto.IUdpPacket} message UdpPacket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UdpPacket.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UdpPacket message from the specified reader or buffer.
         * @function decode
         * @memberof RandoProto.UdpPacket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RandoProto.UdpPacket} UdpPacket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UdpPacket.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RandoProto.UdpPacket();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.udpId = reader.int32();
                    break;
                case 2:
                    message.encryptedPacket = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UdpPacket message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RandoProto.UdpPacket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RandoProto.UdpPacket} UdpPacket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UdpPacket.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UdpPacket message.
         * @function verify
         * @memberof RandoProto.UdpPacket
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UdpPacket.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.udpId != null && message.hasOwnProperty("udpId"))
                if (!$util.isInteger(message.udpId))
                    return "udpId: integer expected";
            if (message.encryptedPacket != null && message.hasOwnProperty("encryptedPacket"))
                if (!(message.encryptedPacket && typeof message.encryptedPacket.length === "number" || $util.isString(message.encryptedPacket)))
                    return "encryptedPacket: buffer expected";
            return null;
        };

        /**
         * Creates an UdpPacket message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RandoProto.UdpPacket
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RandoProto.UdpPacket} UdpPacket
         */
        UdpPacket.fromObject = function fromObject(object) {
            if (object instanceof $root.RandoProto.UdpPacket)
                return object;
            let message = new $root.RandoProto.UdpPacket();
            if (object.udpId != null)
                message.udpId = object.udpId | 0;
            if (object.encryptedPacket != null)
                if (typeof object.encryptedPacket === "string")
                    $util.base64.decode(object.encryptedPacket, message.encryptedPacket = $util.newBuffer($util.base64.length(object.encryptedPacket)), 0);
                else if (object.encryptedPacket.length)
                    message.encryptedPacket = object.encryptedPacket;
            return message;
        };

        /**
         * Creates a plain object from an UdpPacket message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RandoProto.UdpPacket
         * @static
         * @param {RandoProto.UdpPacket} message UdpPacket
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UdpPacket.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.udpId = 0;
                if (options.bytes === String)
                    object.encryptedPacket = "";
                else {
                    object.encryptedPacket = [];
                    if (options.bytes !== Array)
                        object.encryptedPacket = $util.newBuffer(object.encryptedPacket);
                }
            }
            if (message.udpId != null && message.hasOwnProperty("udpId"))
                object.udpId = message.udpId;
            if (message.encryptedPacket != null && message.hasOwnProperty("encryptedPacket"))
                object.encryptedPacket = options.bytes === String ? $util.base64.encode(message.encryptedPacket, 0, message.encryptedPacket.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPacket) : message.encryptedPacket;
            return object;
        };

        /**
         * Converts this UdpPacket to JSON.
         * @function toJSON
         * @memberof RandoProto.UdpPacket
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UdpPacket.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UdpPacket
         * @function getTypeUrl
         * @memberof RandoProto.UdpPacket
         * @static
         * @returns {string} The default type url
         */
        UdpPacket.getTypeUrl = function getTypeUrl() {
            return "type.googleapis.com/RandoProto.UdpPacket";
        };

        return UdpPacket;
    })();

    return RandoProto;
})();
